<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">
    <title>MorseFleet - Morse Code Battleship</title>
    <style>
/* MorseFleet - Mobile-First Responsive Styles */

/* CSS Variables - Matching FirstContact color scheme */
:root {
    --bg-primary: #0f172a;
    --bg-secondary: #1e293b;
    --bg-tertiary: #334155;
    --text-primary: #f8fafc;
    --text-secondary: #94a3b8;
    --text-muted: #64748b;
    --accent-primary: #3b82f6;
    --accent-success: #22c55e;
    --accent-warning: #eab308;
    --accent-danger: #ef4444;
    --border-color: #475569;
    --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    -webkit-tap-highlight-color: transparent;
}

html, body {
    touch-action: manipulation;
    overscroll-behavior: none;
}

body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    line-height: 1.5;
    min-height: 100vh;
    min-height: -webkit-fill-available;
    font-size: 16px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 10px;
    padding-bottom: env(safe-area-inset-bottom, 20px);
}

/* Header */
header {
    margin-bottom: 15px;
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 10px;
}

.header-content {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    flex-wrap: wrap;
}

.parent-logo {
    display: none;
}

.parent-logo.visible {
    display: block;
}

.parent-logo img {
    height: 80px;
    width: auto;
    max-width: 150px;
    object-fit: contain;
}

.header-text {
    text-align: center;
}

header h1 {
    color: var(--accent-primary);
    font-size: 1.5em;
    letter-spacing: 2px;
}

.subtitle {
    color: var(--text-secondary);
    font-size: 0.8em;
}

/* Desktop: larger logo */
@media (min-width: 600px) {
    .parent-logo img {
        height: 100px;
        max-width: 200px;
    }
}

/* Sections */
section {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
}

section h2 {
    color: var(--accent-primary);
    font-size: 1em;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid var(--border-color);
}

/* Game Status */
.game-status {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
}

.status-item {
    text-align: center;
    min-width: 80px;
}

.status-item .label {
    color: var(--text-secondary);
    display: block;
    font-size: 0.7em;
}

.status-item span:not(.label) {
    font-size: 1.3em;
    font-weight: bold;
    color: var(--accent-success);
}

/* Speed Selector */
.speed-selector {
    display: flex;
    align-items: center;
    gap: 6px;
}

.speed-selector .label {
    color: var(--text-secondary);
    font-size: 0.7em;
    white-space: nowrap;
}

.speed-select {
    padding: 6px 10px;
    font-family: inherit;
    font-size: 0.9em;
    background: var(--bg-tertiary);
    color: var(--accent-success);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    min-height: 36px;
    font-weight: bold;
}

.speed-select:hover {
    background: var(--border-color);
}

.speed-select:focus {
    outline: 2px solid var(--accent-success);
    outline-offset: 2px;
}

/* Grid - Mobile First */
.grid-section {
    text-align: center;
    overflow-x: auto;
}

.grid-container {
    display: inline-block;
}

.grid-labels-top {
    display: grid;
    grid-template-columns: 28px repeat(7, 1fr);
    gap: 2px;
    margin-bottom: 2px;
    max-width: calc(28px + 7 * 38px + 12px);
}

.grid-labels-top span {
    text-align: center;
    font-weight: bold;
    color: var(--text-secondary);
    font-size: 0.75em;
}

.grid-with-labels {
    display: flex;
}

.grid-labels-left {
    display: flex;
    flex-direction: column;
    gap: 2px;
    margin-right: 2px;
}

.grid-labels-left span {
    min-width: 28px;
    height: 38px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: var(--text-secondary);
    font-size: 0.75em;
}

.grid {
    display: grid;
    grid-template-columns: repeat(7, 38px);
    grid-template-rows: repeat(7, 38px);
    gap: 2px;
}

.cell {
    background: var(--bg-tertiary);
    border: 1px solid var(--bg-primary);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1em;
    cursor: default;
    transition: background-color 0.15s;
}

.cell.unknown {
    background: var(--bg-tertiary);
}

.cell.water {
    background: var(--bg-secondary);
}

.cell.water::after {
    content: '~';
    color: var(--accent-primary);
}

.cell.hit {
    background: var(--accent-danger);
}

.cell.hit::after {
    content: 'X';
    color: #fff;
    font-weight: bold;
}

.cell.sunk {
    background: #7f1d1d;
}

.cell.sunk::after {
    content: '#';
    color: #ccc;
}

/* Legend */
.legend {
    margin-top: 12px;
    display: flex;
    gap: 15px;
    justify-content: center;
    font-size: 0.75em;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 4px;
}

.cell-sample {
    width: 18px;
    height: 18px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--bg-primary);
    border-radius: 3px;
    font-size: 0.8em;
}

.cell-sample.water { background: var(--bg-secondary); }
.cell-sample.water::after { content: '~'; color: var(--accent-primary); }
.cell-sample.hit { background: var(--accent-danger); }
.cell-sample.hit::after { content: 'X'; color: #fff; }
.cell-sample.sunk { background: #7f1d1d; }
.cell-sample.sunk::after { content: '#'; color: #ccc; }
.cell-sample.ship { background: var(--accent-primary); }
.cell-sample.ship::after { content: '■'; color: #fff; }

/* Morse Display */
.morse-display {
    margin-bottom: 15px;
}

.morse-row {
    display: flex;
    margin-bottom: 6px;
    align-items: center;
    flex-wrap: wrap;
}

.morse-row .label {
    width: 110px;
    color: var(--text-secondary);
    font-size: 0.75em;
    flex-shrink: 0;
}

.morse-text {
    font-size: 1em;
    min-width: 80px;
    padding: 6px 10px;
    background: var(--bg-tertiary);
    border-radius: 4px;
    flex: 1;
}

.morse-text.highlight {
    color: var(--accent-success);
    font-weight: bold;
}

/* Morse Key - Large Touch Target */
.morse-key-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 15px 0;
    touch-action: none;
}

.morse-key {
    width: 90%;
    max-width: 280px;
    height: 100px;
    background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
    border: 4px solid var(--border-color);
    border-radius: 15px;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 1.1em;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    transition: all 0.05s;
    touch-action: none;
}

.morse-key:hover {
    border-color: var(--accent-primary);
}

.morse-key:active,
.morse-key.active {
    background: linear-gradient(180deg, var(--accent-primary) 0%, #2563eb 100%);
    transform: scale(0.98);
    box-shadow: inset 0 3px 8px rgba(0,0,0,0.4);
}

.morse-key small {
    color: var(--text-secondary);
    font-size: 0.65em;
    display: block;
    margin-top: 5px;
}

.signal-indicator {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: var(--bg-tertiary);
    margin-top: 12px;
    border: 2px solid var(--border-color);
    transition: all 0.05s;
}

.signal-indicator.on {
    background: var(--accent-success);
    box-shadow: 0 0 15px var(--accent-success);
}

/* Controls - Touch Friendly */
.controls {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
}

.btn {
    padding: 14px 20px;
    font-family: inherit;
    font-size: 0.95em;
    background: var(--accent-primary);
    color: #fff;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.15s, transform 0.1s;
    min-height: 48px;
    min-width: 48px;
    touch-action: manipulation;
}

.btn:hover {
    background: #60a5fa;
}

.btn:active,
.btn.pressed {
    transform: scale(0.96);
    background: #60a5fa;
    box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
}

.btn:disabled {
    background: var(--text-muted);
    cursor: not-allowed;
    transform: none;
}

.btn-secondary {
    background: var(--bg-tertiary);
}

.btn-secondary:hover {
    background: var(--border-color);
}

/* Response Section */
.response-display {
    text-align: center;
}

.response-row {
    display: flex;
    justify-content: center;
    margin-bottom: 6px;
    align-items: center;
    flex-wrap: wrap;
}

.response-row .label {
    width: 110px;
    color: var(--text-secondary);
    font-size: 0.75em;
    text-align: right;
    padding-right: 8px;
    flex-shrink: 0;
}

.response-text {
    font-size: 1em;
    min-width: 120px;
    text-align: left;
    padding: 6px 10px;
    background: var(--bg-tertiary);
    border-radius: 4px;
}

.response-text.highlight {
    color: var(--accent-primary);
    font-weight: bold;
    font-size: 1.3em;
}

/* Morse Reference */
.morse-reference {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
}

.morse-reference summary {
    cursor: pointer;
    color: var(--accent-primary);
    font-weight: bold;
    outline: none;
    padding: 8px 0;
    font-size: 0.95em;
}

.morse-reference summary:hover {
    color: #60a5fa;
}

.reference-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 15px;
    margin-top: 12px;
}

.ref-section h4 {
    color: var(--text-secondary);
    margin-bottom: 8px;
    font-size: 0.8em;
}

.ref-item {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    padding: 4px 0;
    font-size: 0.85em;
}

.ref-item span:first-child {
    color: var(--accent-success);
}

.ref-item span:last-child {
    font-family: monospace;
    letter-spacing: 2px;
}

/* Footer */
footer {
    text-align: center;
    padding: 15px 10px;
    color: var(--text-muted);
    font-size: 0.7em;
    border-top: 1px solid var(--border-color);
}

.footer-links {
    margin-top: 8px;
}

.footer-links a {
    color: var(--text-secondary);
    text-decoration: none;
    transition: color 0.2s;
}

.footer-links a:hover {
    color: var(--accent-primary);
}

.footer-sep {
    margin: 0 8px;
    color: var(--text-muted);
}

.parent-site-text {
    margin-bottom: 8px;
    color: var(--text-secondary);
}

.parent-site-text a {
    color: var(--accent-primary);
    text-decoration: none;
    font-weight: bold;
}

.parent-site-text a:hover {
    text-decoration: underline;
}

/* Legal Modal */
.legal-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 20px;
    overflow-y: auto;
}

.legal-modal {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    max-width: 600px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
}

.legal-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid var(--border-color);
    position: sticky;
    top: 0;
    background: var(--bg-secondary);
}

.legal-modal-header h2 {
    color: var(--accent-primary);
    margin: 0;
    font-size: 1.2em;
}

.legal-modal-close {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 1.8em;
    cursor: pointer;
    padding: 0;
    line-height: 1;
    transition: color 0.2s;
}

.legal-modal-close:hover {
    color: var(--accent-primary);
}

.legal-modal-content {
    padding: 20px;
}

.legal-info {
    color: var(--text-secondary);
    font-size: 0.85em;
    margin-bottom: 20px;
    font-style: italic;
}

.legal-section {
    margin-bottom: 20px;
}

.legal-section h3 {
    color: var(--accent-success);
    font-size: 1em;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid var(--border-color);
}

.legal-section p {
    color: var(--text-primary);
    font-size: 0.9em;
    line-height: 1.6;
    margin-bottom: 8px;
}

.legal-address p {
    margin-bottom: 4px;
}

.legal-email {
    color: var(--accent-primary);
    text-decoration: none;
}

.legal-email:hover {
    text-decoration: underline;
}

/* Tutorial Button */
.btn-tutorial {
    background: var(--accent-success);
}

.btn-tutorial:hover {
    background: #16a34a;
}

/* Tutorial Modal */
.tutorial-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 15px;
}

.tutorial-modal {
    background: var(--bg-secondary);
    border: 2px solid var(--accent-success);
    border-radius: 15px;
    max-width: 500px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 0 30px rgba(34, 197, 94, 0.3);
}

.tutorial-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-tertiary);
    border-radius: 13px 13px 0 0;
}

.tutorial-header h2 {
    color: var(--accent-success);
    margin: 0;
    font-size: 1.2em;
}

.tutorial-close {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 1.8em;
    cursor: pointer;
    padding: 0;
    line-height: 1;
}

.tutorial-close:hover {
    color: var(--accent-primary);
}

.tutorial-content {
    padding: 20px;
}

.tutorial-step {
    margin-bottom: 25px;
}

.tutorial-step-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}

.tutorial-step-num {
    background: var(--accent-success);
    color: var(--bg-primary);
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.9em;
}

.tutorial-step h3 {
    color: var(--text-primary);
    font-size: 1em;
    margin: 0;
}

.tutorial-step p {
    color: var(--text-secondary);
    font-size: 0.9em;
    line-height: 1.5;
    margin-bottom: 10px;
}

/* Demo Key */
.tutorial-demo {
    background: var(--bg-tertiary);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    text-align: center;
}

.demo-key {
    width: 120px;
    height: 50px;
    background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
    border: 3px solid var(--border-color);
    border-radius: 8px;
    margin: 0 auto 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
    font-size: 0.8em;
    transition: all 0.05s;
}

.demo-key.active {
    background: linear-gradient(180deg, var(--accent-primary) 0%, #2563eb 100%);
    border-color: var(--accent-primary);
    color: #fff;
}

.demo-indicator {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--bg-tertiary);
    margin: 0 auto 10px;
    border: 2px solid var(--border-color);
    transition: all 0.05s;
}

.demo-indicator.on {
    background: var(--accent-success);
    box-shadow: 0 0 10px var(--accent-success);
}

.demo-output {
    font-family: monospace;
    font-size: 1.5em;
    color: var(--accent-success);
    min-height: 1.5em;
    letter-spacing: 3px;
}

.demo-decoded {
    color: var(--accent-primary);
    font-size: 1.2em;
    font-weight: bold;
    min-height: 1.2em;
    margin-top: 5px;
}

/* Morse timing diagram */
.timing-diagram {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    margin: 10px 0;
    flex-wrap: wrap;
}

.timing-dot {
    width: 15px;
    height: 15px;
    background: var(--accent-success);
    border-radius: 50%;
}

.timing-dash {
    width: 45px;
    height: 15px;
    background: var(--accent-success);
    border-radius: 8px;
}

.timing-gap {
    width: 10px;
}

.timing-label {
    font-size: 0.7em;
    color: var(--text-secondary);
    text-align: center;
    margin-top: 3px;
}

/* Tutorial controls */
.tutorial-controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
}

.tutorial-btn-demo {
    background: var(--accent-primary);
    color: #fff;
    border: none;
    padding: 12px 25px;
    border-radius: 8px;
    font-size: 1em;
    cursor: pointer;
    font-family: inherit;
    transition: background 0.2s;
}

.tutorial-btn-demo:hover {
    background: #60a5fa;
}

.tutorial-btn-demo:disabled {
    background: var(--text-muted);
    cursor: not-allowed;
}

.tutorial-progress {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 15px;
}

.tutorial-progress-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
}

.tutorial-progress-dot.active {
    background: var(--accent-success);
    border-color: var(--accent-success);
}

.tutorial-progress-dot.completed {
    background: var(--bg-tertiary);
    border-color: var(--accent-success);
}

/* ===========================================
   TWO-WAY GAMEPLAY STYLES
   =========================================== */

/* Dual Grid Container */
.grids-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
}

@media (min-width: 700px) {
    .grids-container {
        flex-direction: row;
        justify-content: center;
        align-items: flex-start;
        gap: 30px;
    }
}

.grid-section {
    flex: 0 0 auto;
}

.grid-section.player-grid,
.grid-section.enemy-grid {
    min-width: 0;
}

/* Turn Indicator */
.turn-indicator {
    text-align: center;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1em;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}

.turn-indicator.player-turn {
    background: var(--accent-success);
    color: var(--bg-primary);
}

.turn-indicator.computer-turn {
    background: var(--accent-warning);
    color: var(--bg-primary);
}

.turn-indicator.placement-phase {
    background: var(--accent-primary);
    color: white;
}

/* Ship Cells on Player Grid */
.cell.ship {
    background: var(--accent-primary);
}

.cell.ship::after {
    content: '■';
    color: white;
}

.cell.ship.hit {
    background: var(--accent-danger);
}

.cell.ship.hit::after {
    content: 'X';
    color: white;
    font-weight: bold;
}

.cell.ship.sunk {
    background: #7f1d1d;
}

.cell.ship.sunk::after {
    content: '#';
    color: #ccc;
}

/* Ship Placement Preview */
.cell.placement-preview {
    background: rgba(34, 197, 94, 0.5);
    cursor: pointer;
}

.cell.placement-preview::after {
    content: '○';
    color: var(--accent-success);
}

.cell.placement-invalid {
    background: rgba(239, 68, 68, 0.5);
    cursor: not-allowed;
}

.cell.placement-invalid::after {
    content: '○';
    color: var(--accent-danger);
}

.cell.placement-hover {
    cursor: pointer;
}

/* Ship Placement UI */
.placement-ui {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
}

.placement-header {
    text-align: center;
    margin-bottom: 15px;
}

.placement-header h3 {
    color: var(--accent-primary);
    margin-bottom: 5px;
}

.placement-status {
    color: var(--text-secondary);
    font-size: 0.9em;
}

.ship-queue {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    margin-bottom: 15px;
}

.ship-item {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 10px;
    background: var(--bg-tertiary);
    border: 2px solid var(--border-color);
    border-radius: 6px;
    font-size: 0.85em;
}

.ship-item.current {
    border-color: var(--accent-success);
    background: rgba(34, 197, 94, 0.2);
}

.ship-item.placed {
    opacity: 0.5;
    text-decoration: line-through;
}

.ship-cells {
    display: flex;
    gap: 2px;
}

.ship-cell-preview {
    width: 12px;
    height: 12px;
    background: var(--accent-primary);
    border-radius: 2px;
}

.ship-item.placed .ship-cell-preview {
    background: var(--text-muted);
}

.placement-controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

.btn-placement {
    padding: 10px 18px;
    font-size: 0.9em;
}

/* Last Enemy Shot Display */
.last-shot-display {
    text-align: center;
    padding: 10px;
    background: var(--bg-tertiary);
    border-radius: 6px;
    margin-top: 10px;
    min-height: 40px;
}

.last-shot-display.hit {
    background: rgba(239, 68, 68, 0.2);
    border: 1px solid var(--accent-danger);
}

.last-shot-display.miss {
    background: rgba(59, 130, 246, 0.2);
    border: 1px solid var(--accent-primary);
}

/* Enemy Shot Animation */
.cell.last-shot {
    animation: shot-pulse 0.5s ease-out;
}

@keyframes shot-pulse {
    0% {
        transform: scale(1.3);
        box-shadow: 0 0 20px var(--accent-danger);
    }
    100% {
        transform: scale(1);
        box-shadow: none;
    }
}

/* Game Over Modal */
.game-over-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 20px;
}

.game-over-modal {
    background: var(--bg-secondary);
    border: 3px solid var(--accent-success);
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    max-width: 400px;
    width: 100%;
    box-shadow: 0 0 40px rgba(34, 197, 94, 0.3);
}

.game-over-modal.defeat {
    border-color: var(--accent-danger);
    box-shadow: 0 0 40px rgba(239, 68, 68, 0.3);
}

.game-over-modal h2 {
    font-size: 2em;
    margin-bottom: 15px;
}

.game-over-modal.defeat h2 {
    color: var(--accent-danger);
}

.game-over-modal p {
    color: var(--text-secondary);
    margin-bottom: 20px;
}

.game-over-stats {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin-bottom: 20px;
}

.game-over-stat {
    text-align: center;
}

.game-over-stat .value {
    font-size: 1.5em;
    font-weight: bold;
    color: var(--accent-success);
}

.game-over-modal.defeat .game-over-stat .value {
    color: var(--accent-danger);
}

.game-over-stat .label {
    font-size: 0.8em;
    color: var(--text-secondary);
}

/* Dual Stats Display */
.dual-stats {
    display: flex;
    gap: 20px;
    justify-content: center;
    flex-wrap: wrap;
}

.stat-group {
    display: flex;
    gap: 15px;
    align-items: center;
    padding: 8px 15px;
    background: var(--bg-tertiary);
    border-radius: 6px;
}

.stat-group.player-stats {
    border-left: 3px solid var(--accent-success);
}

.stat-group.enemy-stats {
    border-left: 3px solid var(--accent-danger);
}

/* ===========================================
   RESPONSIVE BREAKPOINTS
   =========================================== */

/* Small phones */
@media (max-width: 360px) {
    .grid {
        grid-template-columns: repeat(7, 32px);
        grid-template-rows: repeat(7, 32px);
    }

    .grid-labels-left span {
        min-width: 22px;
        height: 32px;
        font-size: 0.65em;
    }

    .grid-labels-top {
        grid-template-columns: 22px repeat(7, 32px);
    }

    .grid-labels-top span {
        font-size: 0.65em;
    }

    header h1 {
        font-size: 1.3em;
    }

    .morse-key {
        height: 80px;
    }
}

/* Tablets portrait */
@media (min-width: 600px) {
    .container {
        padding: 20px;
    }

    header h1 {
        font-size: 2em;
    }

    .grid {
        grid-template-columns: repeat(7, 45px);
        grid-template-rows: repeat(7, 45px);
    }

    .grid-labels-left span {
        min-width: 32px;
        height: 45px;
    }

    .grid-labels-top {
        grid-template-columns: 32px repeat(7, 45px);
    }

    .morse-key {
        max-width: 320px;
        height: 110px;
        font-size: 1.2em;
    }

    .btn {
        padding: 16px 28px;
        font-size: 1em;
    }

    .morse-row .label,
    .response-row .label {
        width: 140px;
        font-size: 0.85em;
    }

    .morse-text,
    .response-text {
        font-size: 1.1em;
    }
}

/* Tablets landscape / Desktop */
@media (min-width: 800px) {
    .container {
        padding: 30px;
    }

    section {
        padding: 20px;
    }

    .grid {
        grid-template-columns: repeat(7, 50px);
        grid-template-rows: repeat(7, 50px);
    }

    .grid-labels-left span {
        min-width: 36px;
        height: 50px;
    }

    .grid-labels-top {
        grid-template-columns: 36px repeat(7, 50px);
    }

    .cell {
        font-size: 1.3em;
    }

    .morse-key {
        max-width: 350px;
        height: 120px;
    }
}

/* Landscape mode on phones */
@media (max-height: 500px) and (orientation: landscape) {
    .container {
        padding: 8px;
    }

    header {
        margin-bottom: 8px;
        padding-bottom: 5px;
    }

    header h1 {
        font-size: 1.2em;
    }

    .subtitle {
        display: none;
    }

    section {
        padding: 8px;
        margin-bottom: 8px;
    }

    section h2 {
        font-size: 0.9em;
        margin-bottom: 6px;
    }

    .grid {
        grid-template-columns: repeat(7, 30px);
        grid-template-rows: repeat(7, 30px);
    }

    .grid-labels-left span {
        min-width: 22px;
        height: 30px;
        font-size: 0.65em;
    }

    .grid-labels-top {
        grid-template-columns: 22px repeat(7, 30px);
    }

    .grid-labels-top span {
        font-size: 0.65em;
    }

    .morse-key {
        height: 70px;
        max-width: 200px;
    }

    .morse-key-container {
        margin: 8px 0;
    }

    .signal-indicator {
        width: 18px;
        height: 18px;
        margin-top: 6px;
    }

    footer {
        padding: 8px;
    }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    body {
        background-color: var(--bg-primary);
        color: var(--text-primary);
    }
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <a href="#" id="parent-logo-link" class="parent-logo" target="_blank" rel="noopener">
                    <img id="parent-logo-img" src="" alt="">
                </a>
                <div class="header-text">
                    <h1>MorseFleet</h1>
                    <p class="subtitle" data-i18n="subtitle">Morsezeichen Seeschlacht Trainer</p>
                </div>
            </div>
        </header>

        <main>
            <!-- Turn Indicator -->
            <div id="turn-indicator" class="turn-indicator placement-phase" data-i18n="placeYourShips">Platziere deine Schiffe</div>

            <!-- Game Status -->
            <section class="game-status">
                <div class="dual-stats">
                    <div class="stat-group player-stats">
                        <div class="status-item">
                            <span class="label" data-i18n="playerShipsRemaining">Deine Schiffe:</span>
                            <span id="player-ships-remaining">6</span>
                        </div>
                    </div>
                    <div class="stat-group enemy-stats">
                        <div class="status-item">
                            <span class="label" data-i18n="enemyShipsRemaining">Feindliche Schiffe:</span>
                            <span id="enemy-ships-remaining">6</span>
                        </div>
                    </div>
                </div>
                <div class="status-item">
                    <span class="label" data-i18n="shotsFired">Schüsse:</span>
                    <span id="shots-fired">0</span>
                </div>
                <div class="status-item speed-selector">
                    <span class="label" data-i18n="speed">Tempo:</span>
                    <select id="speed-select" class="speed-select">
                        <option value="10">10 WPM</option>
                        <option value="15" selected>15 WPM</option>
                        <option value="20">20 WPM</option>
                        <option value="25">25 WPM</option>
                    </select>
                </div>
                <div class="status-item speed-selector">
                    <span class="label" data-i18n="language">Sprache:</span>
                    <select id="lang-select" class="speed-select">
                        <option value="de" selected>Deutsch</option>
                        <option value="en">English</option>
                        <option value="sl">Slovenščina</option>
                    </select>
                </div>
                <div class="status-item speed-selector">
                    <span class="label" data-i18n="gameMode">Modus:</span>
                    <select id="mode-select" class="speed-select">
                        <option value="normal" selected data-i18n-value="modeNormal">Normal (A-G, 1-7)</option>
                        <option value="advanced" data-i18n-value="modeAdvanced">Erweitert 9×9 (A-Z, 0-9)</option>
                    </select>
                </div>
            </section>

            <!-- Ship Placement UI -->
            <section id="placement-ui" class="placement-ui">
                <div class="placement-header">
                    <h3 data-i18n="placeYourShips">Platziere deine Schiffe</h3>
                    <p id="placement-status" class="placement-status"></p>
                </div>
                <div id="ship-queue" class="ship-queue"></div>
                <div class="placement-controls">
                    <button id="rotate-btn" class="btn btn-secondary btn-placement" data-i18n="rotate">Drehen (R)</button>
                    <button id="random-btn" class="btn btn-secondary btn-placement" data-i18n="randomFleet">Zufällig</button>
                    <button id="confirm-fleet-btn" class="btn btn-placement" disabled data-i18n="confirmFleet">Flotte bestätigen</button>
                </div>
            </section>

            <!-- Dual Grids Container -->
            <div class="grids-container">
                <!-- Player's Fleet Grid -->
                <section class="grid-section player-grid">
                    <h2 data-i18n="yourFleet">Deine Flotte</h2>
                    <div class="grid-container">
                        <div id="player-grid-labels-top" class="grid-labels-top">
                            <span></span>
                            <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span>
                        </div>
                        <div class="grid-with-labels">
                            <div id="player-grid-labels-left" class="grid-labels-left">
                                <span>A</span><span>B</span><span>C</span><span>D</span><span>E</span><span>F</span><span>G</span>
                            </div>
                            <div id="player-grid" class="grid"></div>
                        </div>
                    </div>
                    <div class="legend">
                        <span class="legend-item"><span class="cell-sample ship"></span> <span data-i18n="ship">Schiff</span></span>
                        <span class="legend-item"><span class="cell-sample hit"></span> <span data-i18n="hit">Treffer</span></span>
                        <span class="legend-item"><span class="cell-sample sunk"></span> <span data-i18n="sunk">Versenkt</span></span>
                    </div>
                    <div id="last-shot-display" class="last-shot-display" style="display: none;"></div>
                </section>

                <!-- Enemy Waters Grid (Target Grid) -->
                <section class="grid-section enemy-grid">
                    <h2 data-i18n="enemyWaters">Feindliche Gewässer</h2>
                    <div class="grid-container">
                        <div id="target-grid-labels-top" class="grid-labels-top">
                            <span></span>
                            <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span>
                        </div>
                        <div class="grid-with-labels">
                            <div id="target-grid-labels-left" class="grid-labels-left">
                                <span>A</span><span>B</span><span>C</span><span>D</span><span>E</span><span>F</span><span>G</span>
                            </div>
                            <div id="target-grid" class="grid"></div>
                        </div>
                    </div>
                    <div class="legend">
                        <span class="legend-item"><span class="cell-sample water"></span> <span data-i18n="water">Wasser</span></span>
                        <span class="legend-item"><span class="cell-sample hit"></span> <span data-i18n="hit">Treffer</span></span>
                        <span class="legend-item"><span class="cell-sample sunk"></span> <span data-i18n="sunk">Versenkt</span></span>
                    </div>
                </section>
            </div>

            <!-- Morse Input Section -->
            <section class="morse-section">
                <h2 data-i18n="morseInput">Morseeingabe</h2>

                <div class="morse-display">
                    <div class="morse-row">
                        <span class="label" data-i18n="currentSignal">Aktuelles Signal:</span>
                        <span id="current-signal" class="morse-text"></span>
                    </div>
                    <div class="morse-row">
                        <span class="label" data-i18n="currentChar">Aktuelles Zeichen:</span>
                        <span id="current-char" class="morse-text"></span>
                    </div>
                    <div class="morse-row">
                        <span class="label" data-i18n="decodedInput">Dekodierte Eingabe:</span>
                        <span id="decoded-input" class="morse-text highlight"></span>
                    </div>
                </div>

                <div class="morse-key-container">
                    <button id="morse-key" class="morse-key">
                        MORSETASTE<br>
                        <small>Klicken oder Leertaste</small>
                    </button>
                    <div id="signal-indicator" class="signal-indicator"></div>
                </div>

                <div class="controls">
                    <button id="send-btn" class="btn" data-i18n="send">Senden</button>
                    <button id="clear-btn" class="btn btn-secondary" data-i18n="clear">Löschen</button>
                    <button id="new-game-btn" class="btn btn-secondary" data-i18n="newGame">Neues Spiel</button>
                    <button id="tutorial-btn" class="btn btn-tutorial" data-i18n="tutorial">Anleitung</button>
                </div>
            </section>

            <!-- Computer Response Section -->
            <section class="response-section">
                <h2 data-i18n="computerResponse">Computer Antwort</h2>
                <div class="response-display">
                    <div class="response-row">
                        <span class="label" data-i18n="lastCoord">Letzte Koordinate:</span>
                        <span id="last-coord" class="response-text"></span>
                    </div>
                    <div class="response-row">
                        <span class="label" data-i18n="response">Antwort:</span>
                        <span id="response-char" class="response-text highlight"></span>
                    </div>
                    <div class="response-row">
                        <span class="label" data-i18n="meaning">Bedeutung:</span>
                        <span id="response-meaning" class="response-text"></span>
                    </div>
                </div>
            </section>

            <!-- Morse Reference (Debug/Help) -->
            <details class="morse-reference">
                <summary data-i18n="morseReference">Morsecode Referenz</summary>
                <div id="reference-grid" class="reference-grid">
                    <div id="ref-letters" class="ref-section">
                        <h4 data-i18n="letters">Buchstaben (A-G)</h4>
                        <div class="ref-item"><span>A</span><span>.-</span></div>
                        <div class="ref-item"><span>B</span><span>-...</span></div>
                        <div class="ref-item"><span>C</span><span>-.-.</span></div>
                        <div class="ref-item"><span>D</span><span>-..</span></div>
                        <div class="ref-item"><span>E</span><span>.</span></div>
                        <div class="ref-item"><span>F</span><span>..-.</span></div>
                        <div class="ref-item"><span>G</span><span>--.</span></div>
                    </div>
                    <div id="ref-numbers" class="ref-section">
                        <h4 data-i18n="numbers">Zahlen (1-7)</h4>
                        <div class="ref-item"><span>1</span><span>.----</span></div>
                        <div class="ref-item"><span>2</span><span>..---</span></div>
                        <div class="ref-item"><span>3</span><span>...--</span></div>
                        <div class="ref-item"><span>4</span><span>....-</span></div>
                        <div class="ref-item"><span>5</span><span>.....</span></div>
                        <div class="ref-item"><span>6</span><span>-....</span></div>
                        <div class="ref-item"><span>7</span><span>--...</span></div>
                    </div>
                    <div class="ref-section">
                        <h4 data-i18n="responses">Antworten</h4>
                        <div class="ref-item"><span>S (<span data-i18n="hit">Treffer</span>)</span><span>...</span></div>
                        <div class="ref-item"><span>K (<span data-i18n="sunk">Versenkt</span>)</span><span>-.-</span></div>
                        <div class="ref-item"><span>W (<span data-i18n="water">Wasser</span>)</span><span>.--</span></div>
                        <div class="ref-item"><span>? (Error)</span><span>..--..</span></div>
                    </div>
                </div>
            </details>
        </main>

        <footer>
            <p id="parent-site-text" class="parent-site-text" style="display: none;">
                <span data-i18n="partOf">Teil von</span>
                <a href="#" id="parent-site-link" target="_blank" rel="noopener"></a>
            </p>
            <p><span data-i18n="footerText">MorseFleet - Basierend auf Regeln von</span> <a href="https://www.s59veg.si/" target="_blank" rel="noopener" style="color: var(--accent-primary);">Radioklub Vegova (S59VEG)</a></p>
            <div class="footer-links">
                <a href="#" id="help-link" data-i18n="help">Hilfe</a>
                <span class="footer-sep">|</span>
                <a href="#" id="imprint-link" data-i18n="imprint">Impressum</a>
                <span class="footer-sep">|</span>
                <a href="#" id="privacy-link" data-i18n="privacy">Datenschutz</a>
                <span class="footer-sep">|</span>
                <a href="https://github.com/achildrenmile/morsefleet" target="_blank" rel="noopener">GitHub</a>
            </div>
        </footer>
    </div>

    <script>
/**
 * MorseFleet - Morse Code Naval Battle Game
 * Based on rules by Radioklub Vegova (S59VEG)
 * Mobile-optimized version with touch support
 */

// =============================================================================
// MORSE CODE DEFINITIONS
// =============================================================================

const MORSE_CODE = {
    // Letters A-N (for advanced mode)
    'A': '.-',    'B': '-...',  'C': '-.-.',  'D': '-..',
    'E': '.',     'F': '..-.',  'G': '--.',   'H': '....',
    'I': '..',    'J': '.---',  'K': '-.-',   'L': '.-..',
    'M': '--',    'N': '-.',
    // Full alphabet for future expansion
    'O': '---',   'P': '.--.',  'Q': '--.-',  'R': '.-.',
    'S': '...',   'T': '-',     'U': '..-',   'V': '...-',
    'W': '.--',   'X': '-..-',  'Y': '-.--',  'Z': '--..',
    // Numbers 0-9
    '0': '-----', '1': '.----', '2': '..---', '3': '...--',
    '4': '....-', '5': '.....', '6': '-....', '7': '--...',
    '8': '---..', '9': '----.',
    // Special
    '?': '..--..'
};

const MORSE_DECODE = {};
for (const [char, code] of Object.entries(MORSE_CODE)) {
    MORSE_DECODE[code] = char;
}

// =============================================================================
// MORSE TIMING - Speed-configurable
// =============================================================================
// WPM formula: PARIS = 50 units, so 1 WPM = 1200ms per unit

const MorseTiming = {
    wpm: 15,

    // Calculate unit time in ms from WPM
    getUnit() {
        return Math.round(1200 / this.wpm);
    },

    // Get all timing values based on current WPM
    get() {
        const unit = this.getUnit();
        return {
            UNIT: unit,
            DOT_MAX: unit * 2.5,      // Threshold for dot vs dash input
            DASH_MIN: unit * 2.5,
            CHAR_GAP: unit * 4,       // Gap to finalize character
            WORD_GAP: unit * 7,       // Gap between words
            OUT_DOT: unit,            // Output dot duration
            OUT_DASH: unit * 3,       // Output dash duration
            OUT_INTRA: unit,          // Gap within character
            OUT_INTER: unit * 3       // Gap between characters
        };
    },

    setWPM(wpm) {
        this.wpm = wpm;
    }
};

// For backwards compatibility
const MORSE_TIMING = MorseTiming.get();

// =============================================================================
// INTERNATIONALIZATION (i18n)
// =============================================================================

const i18n = {
    currentLang: 'de',

    translations: {
        de: {
            // Header
            subtitle: 'Morsezeichen Seeschlacht Trainer',
            // Game status
            shipsRemaining: 'Verbleibende Schiffe:',
            shotsFired: 'Schüsse:',
            speed: 'Tempo:',
            language: 'Sprache:',
            gameMode: 'Modus:',
            modeNormal: 'Normal (A-G, 1-7)',
            modeAdvanced: 'Erweitert 9×9 (A-Z, 0-9)',
            result: 'Ergebnis:',
            // Grid
            targetGrid: 'Zielraster',
            water: 'Wasser',
            hit: 'Treffer',
            sunk: 'Versenkt',
            ship: 'Schiff',
            // Morse input
            morseInput: 'Morseeingabe',
            currentSignal: 'Aktuelles Signal:',
            currentChar: 'Aktuelles Zeichen:',
            decodedInput: 'Dekodierte Eingabe:',
            morseKey: 'MORSETASTE',
            holdToSend: 'Klicken oder Leertaste',
            send: 'Senden',
            clear: 'Löschen',
            newGame: 'Neues Spiel',
            tutorial: 'Anleitung',
            // Response
            computerResponse: 'Computer Antwort',
            lastCoord: 'Letzte Koordinate:',
            response: 'Antwort:',
            meaning: 'Bedeutung:',
            shipHit: 'Schiff getroffen!',
            shipSunk: 'Schiff versenkt!',
            waterMiss: 'Wasser (daneben)',
            invalidCoord: 'Ungültige Koordinate',
            alreadyShot: 'Bereits beschossen',
            // Reference
            morseReference: 'Morsecode Referenz',
            letters: 'Buchstaben (A-G)',
            lettersAdvanced: 'Buchstaben (A-Z)',
            numbers: 'Zahlen (1-7)',
            numbersAdvanced: 'Zahlen (0-9)',
            responses: 'Antworten',
            // Footer
            footerText: 'MorseFleet - Basierend auf Regeln von',
            partOf: 'Teil von',
            imprint: 'Impressum',
            privacy: 'Datenschutz',
            // Victory/Defeat
            victory: 'Sieg! Flotte in {shots} Schüssen zerstört.',
            victoryAutoplay: 'Sieg in {shots} Schüssen!',
            defeat: 'Niederlage! Deine Flotte wurde zerstört.',
            // Two-way gameplay
            yourFleet: 'Deine Flotte',
            enemyWaters: 'Feindliche Gewässer',
            yourTurn: 'Du bist dran',
            computerTurn: 'Computer ist dran',
            enemyFiredAt: 'Feind schoss auf: {coord}',
            placeYourShips: 'Platziere deine Schiffe',
            rotate: 'Drehen (R)',
            randomFleet: 'Zufällig',
            confirmFleet: 'Flotte bestätigen',
            carrier: 'Flugzeugträger',
            battleship: 'Schlachtschiff',
            cruiser: 'Kreuzer',
            destroyer: 'Zerstörer',
            placingShip: 'Platziere: {ship} ({size} Felder)',
            shipsToPlace: 'Schiffe zu platzieren:',
            allShipsPlaced: 'Alle Schiffe platziert!',
            playerShipsRemaining: 'Deine Schiffe:',
            enemyShipsRemaining: 'Feindliche Schiffe:',
            // Tutorial
            tutorialTitle: 'Anleitung',
            tutorialStep1Title: 'Punkte und Striche',
            tutorialStep1Text: 'Morsecode verwendet kurze Signale (Punkte) und lange Signale (Striche). Ein <strong>kurzer Druck</strong> (<200ms) erzeugt einen Punkt. Ein <strong>langer Druck</strong> (>200ms) erzeugt einen Strich.',
            dot: 'Punkt',
            dash: 'Strich',
            tutorialStep2Title: 'Zeichentiming',
            tutorialStep2Text: 'Pause zwischen den Signalen um ein Zeichen abzuschließen. Nach ~300ms Pause werden die Punkte und Striche in einen Buchstaben oder eine Zahl dekodiert.',
            tutorialStep3Title: 'Schiffe platzieren',
            tutorialStep3Text: 'Zuerst platzierst du deine Flotte auf dem linken Raster. Klicke um Schiffe zu setzen, <strong>R</strong> zum Drehen. Du kannst auch "Zufällig" für automatische Platzierung wählen.',
            tutorialStep4Title: 'Koordinaten senden',
            tutorialStep4Text: 'Um auf ein Ziel zu schießen, sende einen Buchstaben (A-G) gefolgt von einer Zahl (1-7). Zum Beispiel zielt <strong>A1</strong> auf die obere linke Ecke. Im <strong>Erweiterten Modus</strong> werden Buchstabenpaare (AB-MN) und Zahlenpaare (01-13) verwendet - ideal zum Lernen des gesamten Alphabets!',
            playDemo: '▶ Demo abspielen: "A1"',
            playing: 'Spielt...',
            readyToSend: '✓ Bereit zum Senden!',
            tutorialStep5Title: 'Rundenkampf',
            tutorialStep5Text: 'Nach deinem Schuss feuert der Computer zurück! Beobachte dein Flottenraster für eingehende Treffer. Wer zuerst alle feindlichen Schiffe versenkt, gewinnt!',
            tutorialStep6Title: 'Autoplay Modus',
            tutorialStep6Text: 'Willst du das komplette Spiel in Aktion sehen? Klicke <strong>Spiel automatisch</strong> um das Spiel automatisch spielen zu sehen. Schiffe werden platziert, Koordinaten gesendet, und beide Seiten kämpfen!',
            autoplayGame: '▶ Spiel automatisch',
            // Autoplay
            autoplay: 'AUTOPLAY',
            autoplayStarting: 'Startet...',
            autoplayFiring: 'Feuere auf {coord}...',
            autoplaySending: 'Sende {coord}...',
            autoplayVictory: 'Sieg in {shots} Schüssen!',
            stop: 'Stopp',
            // Help
            help: 'Hilfe',
            helpTitle: 'Spielanleitung',
            helpIntro: 'MorseFleet ist ein Morse-Code Seeschlacht-Trainer. Lerne Morsecode während du gegen den Computer spielst!',
            helpPhase1Title: '1. Schiffe platzieren',
            helpPhase1Text: 'Zu Beginn platzierst du deine 6 Schiffe auf dem linken Raster (Deine Flotte). Klicke auf eine Zelle um ein Schiff zu setzen. Drücke <strong>R</strong> oder den Drehen-Button um das Schiff zu rotieren. Du kannst auch "Zufällig" klicken für automatische Platzierung. Wenn alle Schiffe platziert sind, klicke "Flotte bestätigen".',
            helpPhase2Title: '2. Morsecode eingeben',
            helpPhase2Text: 'Halte die Morsetaste (oder Leertaste) gedrückt um Signale zu senden. <strong>Kurzer Druck</strong> = Punkt (.), <strong>Langer Druck</strong> = Strich (-). Nach einer kurzen Pause wird das Zeichen automatisch erkannt.',
            helpPhase3Title: '3. Koordinaten senden',
            helpPhase3Text: 'Gib einen Buchstaben (A-G) und eine Zahl (1-7) ein, z.B. "B3". Klicke dann "Senden". Der Computer antwortet mit: <strong>W</strong> (Wasser), <strong>S</strong> (Treffer), oder <strong>K</strong> (Versenkt). Im <strong>Erweiterten Modus</strong> verwendest du Buchstabenpaare (AB-MN) und Zahlenpaare (01-13).',
            helpPhase4Title: '4. Rundenkampf',
            helpPhase4Text: 'Nach deinem Schuss feuert der Computer auf deine Flotte zurück. Beobachte das linke Raster für eingehende Treffer. Wer zuerst alle 6 feindlichen Schiffe versenkt, gewinnt!',
            helpMorseTitle: 'Morse-Referenz',
            helpMorseText: 'A=.- B=-... C=-.-. D=-.. E=. F=..-. G=--.<br>1=.---- 2=..--- 3=...-- 4=....- 5=..... 6=-.... 7=--...',
            helpTipsTitle: 'Tipps',
            helpTip1: 'Öffne die "Morsecode Referenz" unter dem Spielfeld als Spickzettel',
            helpTip2: 'Nutze den Autoplay-Modus um zu sehen wie das Spiel funktioniert',
            helpTip3: 'Die Geschwindigkeit (WPM) kannst du oben anpassen',
            helpTip4: 'Wähle den "Erweiterten Modus" um das gesamte Alphabet (A-N) und alle Ziffern (0-9) zu lernen',
            // Imprint
            imprintTitle: 'Impressum',
            imprintInfo: 'Angaben gemäß § 5 ECG und § 25 MedienG',
            imprintOperator: 'Inhaber / Betreiber',
            imprintContact: 'Kontakt',
            imprintLiabilityTitle: 'Haftung für Inhalte',
            imprintLiabilityText: 'Die Inhalte dieser Website wurden mit größter Sorgfalt erstellt. Für die Richtigkeit, Vollständigkeit und Aktualität der Inhalte übernehmen wir jedoch keine Gewähr. Diese Website dient ausschließlich Bildungszwecken im Bereich Amateurfunk und Morsecode.',
            imprintCopyrightTitle: 'Urheberrecht',
            imprintCopyrightText: 'Die durch den Betreiber erstellten Inhalte und Werke auf dieser Website unterliegen dem österreichischen Urheberrecht. Der Quellcode ist unter der MIT-Lizenz auf GitHub verfügbar.',
            // Privacy
            privacyTitle: 'Datenschutzerklärung',
            privacyIntroTitle: 'Datenschutz auf einen Blick',
            privacyIntroText: 'Diese Website speichert keine personenbezogenen Daten. Es werden keine Cookies gesetzt und kein Tracking durchgeführt.',
            privacyCollectionTitle: 'Datenerfassung',
            privacyCollectionText: 'Diese Anwendung läuft vollständig im Browser. Es werden keine Daten an Server übertragen. Alle Spielstände existieren nur lokal während der Sitzung.',
            privacyHostingTitle: 'Hosting',
            privacyHostingText: 'Diese Website wird über Cloudflare bereitgestellt. Cloudflare kann technische Zugriffsdaten (IP-Adresse, Zeitpunkt) in Server-Logs speichern. Details finden Sie in der Datenschutzerklärung von Cloudflare.',
            privacyRightsTitle: 'Ihre Rechte',
            privacyRightsText: 'Sie haben das Recht auf Auskunft, Berichtigung, Löschung und Einschränkung der Verarbeitung Ihrer Daten. Da wir jedoch keine personenbezogenen Daten speichern, fallen diese Rechte praktisch nicht an.'
        },
        en: {
            // Header
            subtitle: 'Morse Code Naval Battle Trainer',
            // Game status
            shipsRemaining: 'Ships Remaining:',
            shotsFired: 'Shots Fired:',
            speed: 'Speed:',
            language: 'Language:',
            gameMode: 'Mode:',
            modeNormal: 'Normal (A-G, 1-7)',
            modeAdvanced: 'Advanced 9×9 (A-Z, 0-9)',
            result: 'Result:',
            // Grid
            targetGrid: 'Target Grid',
            water: 'Water',
            hit: 'Hit',
            sunk: 'Sunk',
            ship: 'Ship',
            // Morse input
            morseInput: 'Morse Input',
            currentSignal: 'Current Signal:',
            currentChar: 'Current Character:',
            decodedInput: 'Decoded Input:',
            morseKey: 'MORSE KEY',
            holdToSend: 'Click or Spacebar',
            send: 'Send',
            clear: 'Clear',
            newGame: 'New Game',
            tutorial: 'Tutorial',
            // Response
            computerResponse: 'Computer Response',
            lastCoord: 'Last Coordinate:',
            response: 'Response:',
            meaning: 'Meaning:',
            shipHit: 'Ship hit!',
            shipSunk: 'Ship sunk!',
            waterMiss: 'Water (miss)',
            invalidCoord: 'Invalid coordinate',
            alreadyShot: 'Already shot here',
            // Reference
            morseReference: 'Morse Code Reference',
            letters: 'Letters (A-G)',
            lettersAdvanced: 'Letters (A-Z)',
            numbers: 'Numbers (1-7)',
            numbersAdvanced: 'Numbers (0-9)',
            responses: 'Responses',
            // Footer
            footerText: 'MorseFleet - Based on rules by',
            partOf: 'Part of',
            imprint: 'Imprint',
            privacy: 'Privacy',
            // Victory/Defeat
            victory: 'Victory! Fleet destroyed in {shots} shots.',
            victoryAutoplay: 'Victory in {shots} shots!',
            defeat: 'Defeat! Your fleet was destroyed.',
            // Two-way gameplay
            yourFleet: 'Your Fleet',
            enemyWaters: 'Enemy Waters',
            yourTurn: 'Your Turn',
            computerTurn: 'Computer\'s Turn',
            enemyFiredAt: 'Enemy fired at: {coord}',
            placeYourShips: 'Place Your Ships',
            rotate: 'Rotate (R)',
            randomFleet: 'Random',
            confirmFleet: 'Confirm Fleet',
            carrier: 'Carrier',
            battleship: 'Battleship',
            cruiser: 'Cruiser',
            destroyer: 'Destroyer',
            placingShip: 'Placing: {ship} ({size} cells)',
            shipsToPlace: 'Ships to place:',
            allShipsPlaced: 'All ships placed!',
            playerShipsRemaining: 'Your Ships:',
            enemyShipsRemaining: 'Enemy Ships:',
            // Tutorial
            tutorialTitle: 'Tutorial',
            tutorialStep1Title: 'Dots and Dashes',
            tutorialStep1Text: 'Morse code uses short signals (dots) and long signals (dashes). A <strong>short press</strong> (<200ms) creates a dot. A <strong>long press</strong> (>200ms) creates a dash.',
            dot: 'Dot',
            dash: 'Dash',
            tutorialStep2Title: 'Character Timing',
            tutorialStep2Text: 'Pause between signals to complete a character. After ~300ms pause, the dots and dashes are decoded into a letter or number.',
            tutorialStep3Title: 'Place Your Ships',
            tutorialStep3Text: 'First, place your fleet on the left grid. Click to place ships, press <strong>R</strong> to rotate. You can also click "Random" for automatic placement.',
            tutorialStep4Title: 'Send Coordinates',
            tutorialStep4Text: 'To fire at a target, send a letter (A-G) followed by a number (1-7). For example, <strong>A1</strong> targets the top-left corner. In <strong>Advanced Mode</strong>, letter pairs (AB-MN) and number pairs (01-13) are used - perfect for learning the full alphabet!',
            playDemo: '▶ Play Demo: "A1"',
            playing: 'Playing...',
            readyToSend: '✓ Ready to send!',
            tutorialStep5Title: 'Turn-Based Combat',
            tutorialStep5Text: 'After your shot, the computer fires back! Watch your fleet grid for incoming hits. First to sink all enemy ships wins!',
            tutorialStep6Title: 'Autoplay Mode',
            tutorialStep6Text: 'Want to see the full game in action? Click <strong>Autoplay Game</strong> to watch. Ships will be placed, coordinates sent, and both sides will battle!',
            autoplayGame: '▶ Autoplay Game',
            // Autoplay
            autoplay: 'AUTOPLAY',
            autoplayStarting: 'Starting...',
            autoplayFiring: 'Firing at {coord}...',
            autoplaySending: 'Sending {coord}...',
            autoplayVictory: 'Victory in {shots} shots!',
            stop: 'Stop',
            // Help
            help: 'Help',
            helpTitle: 'How to Play',
            helpIntro: 'MorseFleet is a Morse code naval battle trainer. Learn Morse code while playing against the computer!',
            helpPhase1Title: '1. Place Your Ships',
            helpPhase1Text: 'At the start, place your 6 ships on the left grid (Your Fleet). Click a cell to place a ship. Press <strong>R</strong> or the Rotate button to rotate the ship. You can also click "Random" for automatic placement. When all ships are placed, click "Confirm Fleet".',
            helpPhase2Title: '2. Enter Morse Code',
            helpPhase2Text: 'Hold the Morse key (or Spacebar) to send signals. <strong>Short press</strong> = dot (.), <strong>Long press</strong> = dash (-). After a brief pause, the character is automatically recognized.',
            helpPhase3Title: '3. Send Coordinates',
            helpPhase3Text: 'Enter a letter (A-G) and a number (1-7), e.g. "B3". Then click "Send". The computer responds with: <strong>W</strong> (Water), <strong>S</strong> (Hit), or <strong>K</strong> (Sunk). In <strong>Advanced Mode</strong>, use letter pairs (AB-MN) and number pairs (01-13).',
            helpPhase4Title: '4. Turn-Based Combat',
            helpPhase4Text: 'After your shot, the computer fires back at your fleet. Watch the left grid for incoming hits. First to sink all 6 enemy ships wins!',
            helpMorseTitle: 'Morse Reference',
            helpMorseText: 'A=.- B=-... C=-.-. D=-.. E=. F=..-. G=--.<br>1=.---- 2=..--- 3=...-- 4=....- 5=..... 6=-.... 7=--...',
            helpTipsTitle: 'Tips',
            helpTip1: 'Open the "Morse Code Reference" below the game grid as a cheat sheet',
            helpTip2: 'Use Autoplay mode to see how the game works',
            helpTip3: 'You can adjust the speed (WPM) at the top',
            helpTip4: 'Select "Advanced Mode" to learn the full alphabet (A-N) and all digits (0-9)',
            // Imprint
            imprintTitle: 'Imprint',
            imprintInfo: 'Information according to § 5 ECG and § 25 MedienG (Austrian law)',
            imprintOperator: 'Owner / Operator',
            imprintContact: 'Contact',
            imprintLiabilityTitle: 'Liability for Content',
            imprintLiabilityText: 'The contents of this website were created with the utmost care. However, we cannot guarantee the accuracy, completeness, or timeliness of the content. This website serves exclusively educational purposes in the field of amateur radio and Morse code.',
            imprintCopyrightTitle: 'Copyright',
            imprintCopyrightText: 'The content and works created by the operator on this website are subject to Austrian copyright law. The source code is available under the MIT license on GitHub.',
            // Privacy
            privacyTitle: 'Privacy Policy',
            privacyIntroTitle: 'Privacy at a Glance',
            privacyIntroText: 'This website does not store any personal data. No cookies are set and no tracking is performed.',
            privacyCollectionTitle: 'Data Collection',
            privacyCollectionText: 'This application runs entirely in the browser. No data is transmitted to servers. All game states exist only locally during the session.',
            privacyHostingTitle: 'Hosting',
            privacyHostingText: 'This website is provided via Cloudflare. Cloudflare may store technical access data (IP address, timestamp) in server logs. Details can be found in Cloudflare\'s privacy policy.',
            privacyRightsTitle: 'Your Rights',
            privacyRightsText: 'You have the right to information, correction, deletion, and restriction of processing of your data. However, since we do not store any personal data, these rights practically do not apply.'
        },
        sl: {
            // Header
            subtitle: 'Morzejeva pomorska bitka',
            // Game status
            shipsRemaining: 'Preostale ladje:',
            shotsFired: 'Streli:',
            speed: 'Hitrost:',
            language: 'Jezik:',
            gameMode: 'Način:',
            modeNormal: 'Normalno (A-G, 1-7)',
            modeAdvanced: 'Napredno 9×9 (A-Z, 0-9)',
            result: 'Rezultat:',
            // Grid
            targetGrid: 'Ciljna mreža',
            water: 'Voda',
            hit: 'Zadetek',
            sunk: 'Potopljena',
            ship: 'Ladja',
            // Morse input
            morseInput: 'Morzejeva tipka',
            currentSignal: 'Trenutni signal:',
            currentChar: 'Trenutni znak:',
            decodedInput: 'Dekodiran vnos:',
            morseKey: 'MORZEJEVA TIPKA',
            holdToSend: 'Klikni ali preslednica',
            send: 'Pošlji',
            clear: 'Briši',
            newGame: 'Nova igra',
            tutorial: 'Navodila',
            // Response
            computerResponse: 'Odgovor računalnika',
            lastCoord: 'Zadnja koordinata:',
            response: 'Odgovor:',
            meaning: 'Pomen:',
            shipHit: 'Ladja zadetena!',
            shipSunk: 'Ladja potopljena!',
            waterMiss: 'Voda (zgrešeno)',
            invalidCoord: 'Neveljavna koordinata',
            alreadyShot: 'Že streljano',
            // Reference
            morseReference: 'Morzejeva referenca',
            letters: 'Črke (A-G)',
            lettersAdvanced: 'Črke (A-Z)',
            numbers: 'Številke (1-7)',
            numbersAdvanced: 'Številke (0-9)',
            responses: 'Odgovori',
            // Footer
            footerText: 'MorseFleet - Po pravilih',
            partOf: 'Del',
            imprint: 'Impressum',
            privacy: 'Zasebnost',
            // Victory/Defeat
            victory: 'Zmaga! Flota uničena v {shots} strelih.',
            victoryAutoplay: 'Zmaga v {shots} strelih!',
            defeat: 'Poraz! Tvoja flota je bila uničena.',
            // Two-way gameplay
            yourFleet: 'Tvoja flota',
            enemyWaters: 'Sovražne vode',
            yourTurn: 'Ti si na vrsti',
            computerTurn: 'Računalnik je na vrsti',
            enemyFiredAt: 'Sovražnik je streljal na: {coord}',
            placeYourShips: 'Postavi svoje ladje',
            rotate: 'Zasukaj (R)',
            randomFleet: 'Naključno',
            confirmFleet: 'Potrdi floto',
            carrier: 'Letalonosilka',
            battleship: 'Bojna ladja',
            cruiser: 'Križarka',
            destroyer: 'Rušilec',
            placingShip: 'Postavljanje: {ship} ({size} polj)',
            shipsToPlace: 'Ladje za postavitev:',
            allShipsPlaced: 'Vse ladje postavljene!',
            playerShipsRemaining: 'Tvoje ladje:',
            enemyShipsRemaining: 'Sovražne ladje:',
            // Tutorial
            tutorialTitle: 'Navodila',
            tutorialStep1Title: 'Pike in črtice',
            tutorialStep1Text: 'Morzejeva abeceda uporablja kratke signale (pike) in dolge signale (črtice). <strong>Kratek pritisk</strong> (<200ms) ustvari piko. <strong>Dolg pritisk</strong> (>200ms) ustvari črtico.',
            dot: 'Pika',
            dash: 'Črtica',
            tutorialStep2Title: 'Časovni razmik',
            tutorialStep2Text: 'Premor med signali zaključi znak. Po ~300ms premora se pike in črtice dekodirajo v črko ali številko.',
            tutorialStep3Title: 'Postavi ladje',
            tutorialStep3Text: 'Najprej postavi svojo floto na levi mreži. Klikni za postavitev ladij, pritisni <strong>R</strong> za rotacijo. Lahko tudi klikneš "Naključno" za samodejno postavitev.',
            tutorialStep4Title: 'Pošlji koordinate',
            tutorialStep4Text: 'Za streljanje na cilj pošlji črko (A-G) in nato številko (1-7). Na primer, <strong>A1</strong> cilja na zgornji levi kot. V <strong>Naprednem načinu</strong> se uporabljajo pari črk (AB-MN) in pari številk (01-13) - idealno za učenje celotne abecede!',
            playDemo: '▶ Predvajaj demo: "A1"',
            playing: 'Predvajanje...',
            readyToSend: '✓ Pripravljeno za pošiljanje!',
            tutorialStep5Title: 'Boj po rundah',
            tutorialStep5Text: 'Po tvojem strelu računalnik strelja nazaj! Opazuj mrežo svoje flote za vhodne zadetke. Kdor prvi potopi vse sovražne ladje, zmaga!',
            tutorialStep6Title: 'Samodejni način',
            tutorialStep6Text: 'Želiš videti celotno igro v akciji? Klikni <strong>Samodejno predvajaj</strong> za ogled. Ladje bodo postavljene, koordinate poslane, in obe strani se bosta borili!',
            autoplayGame: '▶ Samodejno predvajaj',
            // Autoplay
            autoplay: 'SAMODEJNO',
            autoplayStarting: 'Začenjam...',
            autoplayFiring: 'Streljam na {coord}...',
            autoplaySending: 'Pošiljam {coord}...',
            autoplayVictory: 'Zmaga v {shots} strelih!',
            stop: 'Ustavi',
            // Help
            help: 'Pomoč',
            helpTitle: 'Kako igrati',
            helpIntro: 'MorseFleet je Morze-kodni trener pomorske bitke. Nauči se Morzejevo abecedo med igranjem proti računalniku!',
            helpPhase1Title: '1. Postavi ladje',
            helpPhase1Text: 'Na začetku postavi svojih 6 ladij na levo mrežo (Tvoja flota). Klikni na celico za postavitev ladje. Pritisni <strong>R</strong> ali gumb Zasukaj za rotacijo. Lahko tudi klikneš "Naključno" za samodejno postavitev. Ko so vse ladje postavljene, klikni "Potrdi floto".',
            helpPhase2Title: '2. Vnesi Morzejevo kodo',
            helpPhase2Text: 'Drži Morzejevo tipko (ali preslednico) za pošiljanje signalov. <strong>Kratek pritisk</strong> = pika (.), <strong>Dolg pritisk</strong> = črtica (-). Po kratkem premoru se znak samodejno prepozna.',
            helpPhase3Title: '3. Pošlji koordinate',
            helpPhase3Text: 'Vnesi črko (A-G) in številko (1-7), npr. "B3". Nato klikni "Pošlji". Računalnik odgovori z: <strong>W</strong> (Voda), <strong>S</strong> (Zadetek), ali <strong>K</strong> (Potopljena). V <strong>Naprednem načinu</strong> uporabi pare črk (AB-MN) in pare številk (01-13).',
            helpPhase4Title: '4. Boj po rundah',
            helpPhase4Text: 'Po tvojem strelu računalnik strelja nazaj na tvojo floto. Opazuj levo mrežo za vhodne zadetke. Kdor prvi potopi vseh 6 sovražnih ladij, zmaga!',
            helpMorseTitle: 'Morzejeva referenca',
            helpMorseText: 'A=.- B=-... C=-.-. D=-.. E=. F=..-. G=--.<br>1=.---- 2=..--- 3=...-- 4=....- 5=..... 6=-.... 7=--...',
            helpTipsTitle: 'Nasveti',
            helpTip1: 'Odpri "Morzejeva referenca" pod igralno mrežo kot plonk listek',
            helpTip2: 'Uporabi samodejni način da vidiš kako igra deluje',
            helpTip3: 'Hitrost (WPM) lahko prilagodiš na vrhu',
            helpTip4: 'Izberi "Napredni način" za učenje celotne abecede (A-N) in vseh številk (0-9)',
            // Imprint
            imprintTitle: 'Impressum',
            imprintInfo: 'Podatki v skladu s § 5 ECG in § 25 MedienG (avstrijska zakonodaja)',
            imprintOperator: 'Lastnik / Upravljavec',
            imprintContact: 'Kontakt',
            imprintLiabilityTitle: 'Odgovornost za vsebino',
            imprintLiabilityText: 'Vsebina te spletne strani je bila ustvarjena z največjo skrbnostjo. Vendar ne moremo zagotoviti točnosti, popolnosti ali pravočasnosti vsebine. Ta spletna stran služi izključno izobraževalnim namenom na področju radioamaterstva in Morzejeve abecede.',
            imprintCopyrightTitle: 'Avtorske pravice',
            imprintCopyrightText: 'Vsebina in dela, ki jih je ustvaril upravljavec na tej spletni strani, so predmet avstrijskega avtorskega prava. Izvorna koda je na voljo pod licenco MIT na GitHub.',
            // Privacy
            privacyTitle: 'Politika zasebnosti',
            privacyIntroTitle: 'Zasebnost na kratko',
            privacyIntroText: 'Ta spletna stran ne shranjuje nobenih osebnih podatkov. Piškotki niso nastavljeni in sledenje se ne izvaja.',
            privacyCollectionTitle: 'Zbiranje podatkov',
            privacyCollectionText: 'Ta aplikacija deluje v celoti v brskalniku. Podatki se ne prenašajo na strežnike. Vsa stanja iger obstajajo samo lokalno med sejo.',
            privacyHostingTitle: 'Gostovanje',
            privacyHostingText: 'Ta spletna stran je na voljo prek Cloudflare. Cloudflare lahko shranjuje tehnične dostopovne podatke (IP naslov, časovni žig) v strežniških dnevnikih. Podrobnosti najdete v politiki zasebnosti Cloudflare.',
            privacyRightsTitle: 'Vaše pravice',
            privacyRightsText: 'Imate pravico do informacij, popravkov, izbrisa in omejitve obdelave vaših podatkov. Vendar ker ne shranjujemo nobenih osebnih podatkov, te pravice praktično ne veljajo.'
        }
    },

    t(key, replacements = {}) {
        let text = this.translations[this.currentLang]?.[key] || this.translations['en'][key] || key;
        for (const [k, v] of Object.entries(replacements)) {
            text = text.replace(`{${k}}`, v);
        }
        return text;
    },

    setLang(lang) {
        if (this.translations[lang]) {
            this.currentLang = lang;
            this.updateUI();
            localStorage.setItem('morsefleet-lang', lang);
        }
    },

    updateUI() {
        // Update all translatable elements
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                el.placeholder = this.t(key);
            } else {
                el.innerHTML = this.t(key);
            }
        });
        // Update select option texts (data-i18n-value)
        document.querySelectorAll('[data-i18n-value]').forEach(el => {
            const key = el.getAttribute('data-i18n-value');
            el.textContent = this.t(key);
        });
        // Update morse key (special handling for <br>)
        const morseKey = document.getElementById('morse-key');
        if (morseKey) {
            morseKey.innerHTML = `${this.t('morseKey')}<br><small>${this.t('holdToSend')}</small>`;
        }
    },

    init() {
        const saved = localStorage.getItem('morsefleet-lang');
        if (saved && this.translations[saved]) {
            this.currentLang = saved;
        }
        this.updateUI();
    }
};

// =============================================================================
// AUDIO OUTPUT (Web Audio API)
// =============================================================================

class MorseAudio {
    constructor() {
        this.audioCtx = null;
        this.oscillator = null;
        this.gainNode = null;
        this.frequency = 600;
    }

    init() {
        if (!this.audioCtx) {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
        }
    }

    startTone() {
        this.init();
        if (this.oscillator) {
            this.stopTone();
        }

        this.oscillator = this.audioCtx.createOscillator();
        this.gainNode = this.audioCtx.createGain();

        this.oscillator.type = 'sine';
        this.oscillator.frequency.setValueAtTime(this.frequency, this.audioCtx.currentTime);

        this.gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
        this.gainNode.gain.linearRampToValueAtTime(0.3, this.audioCtx.currentTime + 0.01);

        this.oscillator.connect(this.gainNode);
        this.gainNode.connect(this.audioCtx.destination);
        this.oscillator.start();
    }

    stopTone() {
        if (this.oscillator && this.gainNode) {
            const now = this.audioCtx.currentTime;
            this.gainNode.gain.cancelScheduledValues(now);
            this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);
            this.gainNode.gain.linearRampToValueAtTime(0, now + 0.01);

            const osc = this.oscillator;
            setTimeout(() => {
                try { osc.stop(); } catch (e) {}
            }, 20);

            this.oscillator = null;
            this.gainNode = null;
        }
    }

    async playMorse(morseString) {
        this.init();
        const timing = MorseTiming.get();

        for (let i = 0; i < morseString.length; i++) {
            const symbol = morseString[i];

            if (symbol === '.') {
                this.startTone();
                await this.sleep(timing.OUT_DOT);
                this.stopTone();
            } else if (symbol === '-') {
                this.startTone();
                await this.sleep(timing.OUT_DASH);
                this.stopTone();
            }

            if (i < morseString.length - 1) {
                await this.sleep(timing.OUT_INTRA);
            }
        }
    }

    async playChar(char) {
        const morse = MORSE_CODE[char.toUpperCase()];
        if (morse) {
            await this.playMorse(morse);
        }
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// =============================================================================
// MORSE INPUT HANDLING
// =============================================================================

class MorseInput {
    constructor(audio, onUpdate) {
        this.audio = audio;
        this.onUpdate = onUpdate;

        this.isKeyDown = false;
        this.keyDownTime = 0;
        this.keyUpTime = 0;

        this.currentSymbols = '';
        this.decodedChars = '';

        this.gapTimer = null;
    }

    keyDown() {
        if (this.isKeyDown) return;

        this.isKeyDown = true;
        this.keyDownTime = Date.now();

        if (this.gapTimer) {
            clearTimeout(this.gapTimer);
            this.gapTimer = null;
        }

        this.audio.startTone();
        this.updateUI();
    }

    keyUp() {
        if (!this.isKeyDown) return;

        this.isKeyDown = false;
        this.keyUpTime = Date.now();

        const duration = this.keyUpTime - this.keyDownTime;

        this.audio.stopTone();

        // Dot: short signal (<= DOT_MAX ms), Dash: long signal
        const timing = MorseTiming.get();
        if (duration <= timing.DOT_MAX) {
            this.currentSymbols += '.';
        } else {
            this.currentSymbols += '-';
        }

        this.startGapTimer();
        this.updateUI();
    }

    startGapTimer() {
        if (this.gapTimer) {
            clearTimeout(this.gapTimer);
        }

        const timing = MorseTiming.get();
        this.gapTimer = setTimeout(() => {
            this.finalizeCharacter();
        }, timing.CHAR_GAP);
    }

    finalizeCharacter() {
        if (this.currentSymbols) {
            const decoded = MORSE_DECODE[this.currentSymbols];
            if (decoded) {
                this.decodedChars += decoded;
            } else {
                this.decodedChars += '?';
            }
            this.currentSymbols = '';
            this.updateUI();
        }
    }

    getDecodedInput() {
        return this.decodedChars;
    }

    clear() {
        this.currentSymbols = '';
        this.decodedChars = '';
        if (this.gapTimer) {
            clearTimeout(this.gapTimer);
            this.gapTimer = null;
        }
        this.updateUI();
    }

    finalize() {
        this.finalizeCharacter();
    }

    updateUI() {
        if (this.onUpdate) {
            this.onUpdate({
                isKeyDown: this.isKeyDown,
                currentSymbols: this.currentSymbols,
                decodedChars: this.decodedChars
            });
        }
    }
}

// =============================================================================
// SHIP PLACEMENT
// =============================================================================

class Ship {
    constructor(cells) {
        this.cells = cells;
        this.hits = new Set();
    }

    occupies(row, col) {
        return this.cells.some(cell => cell.row === row && cell.col === col);
    }

    hit(row, col) {
        for (let i = 0; i < this.cells.length; i++) {
            if (this.cells[i].row === row && this.cells[i].col === col) {
                this.hits.add(i);
                break;
            }
        }
        return this.isSunk();
    }

    isSunk() {
        return this.hits.size === this.cells.length;
    }
}

/**
 * ShipPlacer: Random ship placement with rules enforcement
 * - Ships horizontal or vertical only
 * - Ships cannot touch (not even diagonally)
 */
class ShipPlacer {
    constructor(gridSize = 7, shipSizes = [4, 3, 3, 2, 2, 2]) {
        this.gridSize = gridSize;
        this.shipSizes = shipSizes;
    }

    placeShips() {
        const ships = [];
        const occupied = this.createEmptyGrid();

        for (const size of this.shipSizes) {
            const ship = this.placeShip(size, occupied);
            if (ship) {
                ships.push(ship);
                this.markOccupied(ship, occupied);
            } else {
                return this.placeShips(); // Retry
            }
        }

        return ships;
    }

    createEmptyGrid() {
        const grid = [];
        for (let i = 0; i < this.gridSize; i++) {
            grid.push(new Array(this.gridSize).fill(false));
        }
        return grid;
    }

    placeShip(size, occupied) {
        const maxAttempts = 100;

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const horizontal = Math.random() < 0.5;

            let row, col;
            if (horizontal) {
                row = Math.floor(Math.random() * this.gridSize);
                col = Math.floor(Math.random() * (this.gridSize - size + 1));
            } else {
                row = Math.floor(Math.random() * (this.gridSize - size + 1));
                col = Math.floor(Math.random() * this.gridSize);
            }

            const cells = [];
            for (let i = 0; i < size; i++) {
                if (horizontal) {
                    cells.push({ row, col: col + i });
                } else {
                    cells.push({ row: row + i, col });
                }
            }

            if (this.isValidPlacement(cells, occupied)) {
                return new Ship(cells);
            }
        }

        return null;
    }

    isValidPlacement(cells, occupied) {
        for (const cell of cells) {
            if (cell.row < 0 || cell.row >= this.gridSize ||
                cell.col < 0 || cell.col >= this.gridSize) {
                return false;
            }
            if (occupied[cell.row][cell.col]) {
                return false;
            }
        }
        return true;
    }

    // Mark ship cells + surrounding cells (enforces no-touching rule)
    markOccupied(ship, occupied) {
        for (const cell of ship.cells) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const r = cell.row + dr;
                    const c = cell.col + dc;
                    if (r >= 0 && r < this.gridSize && c >= 0 && c < this.gridSize) {
                        occupied[r][c] = true;
                    }
                }
            }
        }
    }
}

// =============================================================================
// SHIP PLACEMENT MANAGER (Player's manual ship placement)
// =============================================================================

/**
 * ShipPlacementManager: Handles interactive ship placement for the player
 * - Click to place ships
 * - R key or button to rotate
 * - Random placement option
 * - Validation and preview
 */
class ShipPlacementManager {
    constructor(gridSize = 7, shipSizes = [4, 3, 3, 2, 2, 2]) {
        this.gridSize = gridSize;
        this.shipSizes = shipSizes;
        this.reset();
    }

    setConfig(gridSize, shipSizes) {
        this.gridSize = gridSize;
        this.shipSizes = shipSizes;
        this.reset();
    }

    reset() {
        // Build ship queue from sizes
        this.shipQueue = this.shipSizes.map(size => {
            let name = 'destroyer';
            if (size >= 5) name = 'carrier';
            else if (size >= 4) name = 'battleship';
            else if (size >= 3) name = 'cruiser';
            return { size, name };
        });

        this.placedShips = [];
        this.currentIndex = 0;
        this.isHorizontal = true;
        this.occupied = this.createEmptyGrid();
        this.previewCells = [];
    }

    createEmptyGrid() {
        const grid = [];
        for (let i = 0; i < this.gridSize; i++) {
            grid.push(new Array(this.gridSize).fill(false));
        }
        return grid;
    }

    getCurrentShip() {
        if (this.currentIndex >= this.shipQueue.length) {
            return null;
        }
        return this.shipQueue[this.currentIndex];
    }

    isPlacementComplete() {
        return this.currentIndex >= this.shipQueue.length;
    }

    rotate() {
        this.isHorizontal = !this.isHorizontal;
    }

    /**
     * Get preview cells for placing ship at given position
     * Returns { cells: [], valid: boolean }
     */
    getPreview(row, col) {
        const ship = this.getCurrentShip();
        if (!ship) return { cells: [], valid: false };

        const cells = [];
        for (let i = 0; i < ship.size; i++) {
            if (this.isHorizontal) {
                cells.push({ row, col: col + i });
            } else {
                cells.push({ row: row + i, col });
            }
        }

        const valid = this.isValidPlacement(cells);
        return { cells, valid };
    }

    /**
     * Check if placement is valid
     */
    isValidPlacement(cells) {
        for (const cell of cells) {
            if (cell.row < 0 || cell.row >= this.gridSize ||
                cell.col < 0 || cell.col >= this.gridSize) {
                return false;
            }
            if (this.occupied[cell.row][cell.col]) {
                return false;
            }
        }
        return true;
    }

    /**
     * Place ship at given position
     * Returns true if successful
     */
    placeShip(row, col) {
        const preview = this.getPreview(row, col);
        if (!preview.valid) return false;

        const ship = new Ship(preview.cells);
        this.placedShips.push(ship);

        // Mark occupied cells (including surrounding)
        for (const cell of preview.cells) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const r = cell.row + dr;
                    const c = cell.col + dc;
                    if (r >= 0 && r < this.gridSize && c >= 0 && c < this.gridSize) {
                        this.occupied[r][c] = true;
                    }
                }
            }
        }

        this.currentIndex++;
        return true;
    }

    /**
     * Remove last placed ship (undo)
     */
    undoLastShip() {
        if (this.placedShips.length === 0) return false;

        this.placedShips.pop();
        this.currentIndex--;

        // Rebuild occupied grid
        this.occupied = this.createEmptyGrid();
        for (const ship of this.placedShips) {
            for (const cell of ship.cells) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const r = cell.row + dr;
                        const c = cell.col + dc;
                        if (r >= 0 && r < this.gridSize && c >= 0 && c < this.gridSize) {
                            this.occupied[r][c] = true;
                        }
                    }
                }
            }
        }

        return true;
    }

    /**
     * Place all ships randomly
     */
    placeRandomly() {
        this.reset();
        const placer = new ShipPlacer(this.gridSize);
        this.placedShips = placer.placeShips();
        this.currentIndex = this.shipQueue.length;

        // Update occupied grid
        for (const ship of this.placedShips) {
            for (const cell of ship.cells) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const r = cell.row + dr;
                        const c = cell.col + dc;
                        if (r >= 0 && r < this.gridSize && c >= 0 && c < this.gridSize) {
                            this.occupied[r][c] = true;
                        }
                    }
                }
            }
        }
    }

    /**
     * Get all placed ship cells for display
     */
    getPlacedShipCells() {
        const cells = [];
        for (const ship of this.placedShips) {
            for (const cell of ship.cells) {
                cells.push(cell);
            }
        }
        return cells;
    }

    /**
     * Get the final ships array
     */
    getShips() {
        return this.placedShips;
    }
}

// =============================================================================
// COMPUTER AI (Hunt-and-Target Algorithm)
// =============================================================================

/**
 * ComputerAI: Implements intelligent shot selection for the computer
 * - Hunt mode: Random shots with checkerboard pattern for efficiency
 * - Target mode: After a hit, try adjacent cells
 * - Line tracking: When 2+ hits found, follow the ship direction
 */
class ComputerAI {
    constructor(gridSize = 7) {
        this.gridSize = gridSize;
        this.reset();
    }

    setGridSize(gridSize) {
        this.gridSize = gridSize;
        this.reset();
    }

    reset() {
        // Track all shots made
        this.shots = this.createEmptyGrid();  // false = not shot, true = shot

        // Track hits that haven't been fully resolved (ship not sunk yet)
        this.unresolvedHits = [];

        // Current targeting info when we have hits
        this.targetMode = false;
        this.targetStack = [];  // Cells to try next

        // Track direction when we find a line
        this.detectedDirection = null;  // 'horizontal' or 'vertical'
    }

    createEmptyGrid() {
        const grid = [];
        for (let i = 0; i < this.gridSize; i++) {
            grid.push(new Array(this.gridSize).fill(false));
        }
        return grid;
    }

    /**
     * Get next shot coordinates
     * Returns { row, col } or null if no valid shots remain
     */
    getNextShot() {
        // If we have targets from previous hits, try those first
        if (this.targetStack.length > 0) {
            while (this.targetStack.length > 0) {
                const target = this.targetStack.pop();
                if (this.isValidTarget(target.row, target.col)) {
                    return target;
                }
            }
        }

        // Hunt mode: find a random cell to shoot
        return this.getHuntShot();
    }

    /**
     * Hunt mode: Get a random shot using checkerboard pattern for efficiency
     */
    getHuntShot() {
        const available = [];

        // Checkerboard pattern: (row + col) % 2 === 0 for efficiency
        // This ensures we don't waste shots on cells that can't have a 2-cell ship
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                if (!this.shots[row][col] && (row + col) % 2 === 0) {
                    available.push({ row, col });
                }
            }
        }

        // If checkerboard is exhausted, use remaining cells
        if (available.length === 0) {
            for (let row = 0; row < this.gridSize; row++) {
                for (let col = 0; col < this.gridSize; col++) {
                    if (!this.shots[row][col]) {
                        available.push({ row, col });
                    }
                }
            }
        }

        if (available.length === 0) {
            return null;
        }

        // Random selection
        const index = Math.floor(Math.random() * available.length);
        return available[index];
    }

    /**
     * Check if a cell is a valid target (in bounds and not shot yet)
     */
    isValidTarget(row, col) {
        return row >= 0 && row < this.gridSize &&
               col >= 0 && col < this.gridSize &&
               !this.shots[row][col];
    }

    /**
     * Record the result of a shot
     * @param row - Row of the shot
     * @param col - Column of the shot
     * @param result - 'W' (water), 'S' (hit), 'K' (sunk)
     */
    recordShot(row, col, result) {
        this.shots[row][col] = true;

        if (result === 'S') {
            // Hit but not sunk - add to unresolved and enter target mode
            this.unresolvedHits.push({ row, col });
            this.targetMode = true;
            this.addAdjacentTargets(row, col);
        } else if (result === 'K') {
            // Ship sunk - clear targeting for this ship
            this.unresolvedHits.push({ row, col });
            this.clearSunkShip();
        }
        // If 'W' (water), just continue
    }

    /**
     * Add adjacent cells to target stack
     */
    addAdjacentTargets(row, col) {
        const directions = [
            { dr: -1, dc: 0 },  // up
            { dr: 1, dc: 0 },   // down
            { dr: 0, dc: -1 },  // left
            { dr: 0, dc: 1 }    // right
        ];

        // If we've detected a direction, prioritize that direction
        if (this.detectedDirection === 'horizontal') {
            // Prioritize left/right
            this.addTargetIfValid(row, col - 1);
            this.addTargetIfValid(row, col + 1);
        } else if (this.detectedDirection === 'vertical') {
            // Prioritize up/down
            this.addTargetIfValid(row - 1, col);
            this.addTargetIfValid(row + 1, col);
        } else {
            // No direction detected yet, add all adjacent
            for (const dir of directions) {
                this.addTargetIfValid(row + dir.dr, col + dir.dc);
            }
        }

        // Try to detect direction from unresolved hits
        this.detectDirection();
    }

    /**
     * Add a cell to target stack if valid
     */
    addTargetIfValid(row, col) {
        if (this.isValidTarget(row, col)) {
            // Check if not already in stack
            const exists = this.targetStack.some(t => t.row === row && t.col === col);
            if (!exists) {
                this.targetStack.push({ row, col });
            }
        }
    }

    /**
     * Detect ship direction from multiple hits
     */
    detectDirection() {
        if (this.unresolvedHits.length < 2) {
            this.detectedDirection = null;
            return;
        }

        // Check if hits are in a line
        const rows = new Set(this.unresolvedHits.map(h => h.row));
        const cols = new Set(this.unresolvedHits.map(h => h.col));

        if (rows.size === 1) {
            this.detectedDirection = 'horizontal';
            this.refineTargetStack();
        } else if (cols.size === 1) {
            this.detectedDirection = 'vertical';
            this.refineTargetStack();
        } else {
            this.detectedDirection = null;
        }
    }

    /**
     * Refine target stack based on detected direction
     */
    refineTargetStack() {
        if (!this.detectedDirection || this.unresolvedHits.length === 0) return;

        // Clear current targets
        this.targetStack = [];

        // Find the extent of the hit line
        if (this.detectedDirection === 'horizontal') {
            const row = this.unresolvedHits[0].row;
            const cols = this.unresolvedHits.map(h => h.col).sort((a, b) => a - b);
            const minCol = cols[0];
            const maxCol = cols[cols.length - 1];

            // Add cells at both ends of the line
            this.addTargetIfValid(row, minCol - 1);
            this.addTargetIfValid(row, maxCol + 1);
        } else {
            const col = this.unresolvedHits[0].col;
            const rows = this.unresolvedHits.map(h => h.row).sort((a, b) => a - b);
            const minRow = rows[0];
            const maxRow = rows[rows.length - 1];

            // Add cells at both ends of the line
            this.addTargetIfValid(minRow - 1, col);
            this.addTargetIfValid(maxRow + 1, col);
        }
    }

    /**
     * Clear targeting data when a ship is sunk
     */
    clearSunkShip() {
        // Reset targeting mode
        this.unresolvedHits = [];
        this.targetStack = [];
        this.targetMode = false;
        this.detectedDirection = null;
    }
}

// =============================================================================
// GAME STATE
// =============================================================================

const CellState = {
    UNKNOWN: 'unknown',
    WATER: 'water',
    HIT: 'hit',
    SUNK: 'sunk',
    SHIP: 'ship'  // For player's own ships
};

const GamePhase = {
    PLACEMENT: 'placement',
    BATTLE: 'battle',
    GAME_OVER: 'game_over'
};

const Turn = {
    PLAYER: 'player',
    COMPUTER: 'computer'
};

class GameState {
    constructor() {
        this.gameMode = 'normal'; // 'normal' or 'advanced'
        this.gridSize = 7;
        this.reset();
    }

    setGameMode(mode) {
        this.gameMode = mode;
        this.gridSize = (mode === 'advanced') ? 9 : 7;
    }

    getShipSizes() {
        // Normal mode (7x7): 6 ships - 4, 3, 3, 2, 2, 2
        // Advanced mode (9x9): 9 ships - 5, 4, 4, 3, 3, 3, 2, 2, 2
        if (this.gameMode === 'advanced') {
            return [5, 4, 4, 3, 3, 3, 2, 2, 2];
        }
        return [4, 3, 3, 2, 2, 2];
    }

    reset() {
        // Computer's ships (enemy fleet)
        const placer = new ShipPlacer(this.gridSize, this.getShipSizes());
        this.enemyShips = placer.placeShips();

        // Player's ships (will be placed manually or randomly)
        this.playerShips = [];

        // Target grid (where player shoots - tracks hits on enemy)
        this.targetGrid = [];
        for (let i = 0; i < this.gridSize; i++) {
            this.targetGrid.push(new Array(this.gridSize).fill(CellState.UNKNOWN));
        }

        // Player grid (where computer shoots - shows player's ships and incoming fire)
        this.playerGrid = [];
        for (let i = 0; i < this.gridSize; i++) {
            this.playerGrid.push(new Array(this.gridSize).fill(CellState.UNKNOWN));
        }

        this.shotsFired = 0;
        this.enemyShipsRemaining = this.enemyShips.length;
        this.playerShipsRemaining = 0; // Will be set when ships are placed

        // Game phase and turn tracking
        this.phase = GamePhase.PLACEMENT;
        this.currentTurn = Turn.PLAYER;
        this.winner = null;
        this.isGameOver = false;

        // For backwards compatibility
        this.ships = this.enemyShips;
        this.shipsRemaining = this.enemyShipsRemaining;
    }

    /**
     * Set player's ships after placement phase
     */
    setPlayerShips(ships) {
        this.playerShips = ships;
        this.playerShipsRemaining = ships.length;

        // Update player grid to show ships
        for (const ship of ships) {
            for (const cell of ship.cells) {
                this.playerGrid[cell.row][cell.col] = CellState.SHIP;
            }
        }
    }

    /**
     * Start the battle phase
     */
    startBattle() {
        this.phase = GamePhase.BATTLE;
        this.currentTurn = Turn.PLAYER;
    }

    /**
     * Process player's shot at enemy - returns 'S' (hit), 'K' (sunk), 'W' (water)
     */
    processShot(row, col) {
        if (this.targetGrid[row][col] !== CellState.UNKNOWN) {
            return 'W';
        }

        this.shotsFired++;

        for (const ship of this.enemyShips) {
            if (ship.occupies(row, col)) {
                const sunk = ship.hit(row, col);

                if (sunk) {
                    for (const cell of ship.cells) {
                        this.targetGrid[cell.row][cell.col] = CellState.SUNK;
                    }
                    this.enemyShipsRemaining--;
                    this.shipsRemaining = this.enemyShipsRemaining;

                    if (this.enemyShipsRemaining === 0) {
                        this.phase = GamePhase.GAME_OVER;
                        this.winner = 'player';
                        this.isGameOver = true;
                    }

                    return 'K';
                } else {
                    this.targetGrid[row][col] = CellState.HIT;
                    return 'S';
                }
            }
        }

        this.targetGrid[row][col] = CellState.WATER;
        return 'W';
    }

    /**
     * Process computer's shot at player - returns 'S' (hit), 'K' (sunk), 'W' (water)
     */
    processComputerShot(row, col) {
        const currentState = this.playerGrid[row][col];

        // Can't shoot at already shot cells
        if (currentState === CellState.WATER || currentState === CellState.HIT || currentState === CellState.SUNK) {
            return null; // Invalid shot
        }

        for (const ship of this.playerShips) {
            if (ship.occupies(row, col)) {
                const sunk = ship.hit(row, col);

                if (sunk) {
                    for (const cell of ship.cells) {
                        this.playerGrid[cell.row][cell.col] = CellState.SUNK;
                    }
                    this.playerShipsRemaining--;

                    if (this.playerShipsRemaining === 0) {
                        this.phase = GamePhase.GAME_OVER;
                        this.winner = 'computer';
                        this.isGameOver = true;
                    }

                    return 'K';
                } else {
                    this.playerGrid[row][col] = CellState.HIT;
                    return 'S';
                }
            }
        }

        // No ship at this location - water
        this.playerGrid[row][col] = CellState.WATER;
        return 'W';
    }

    /**
     * Switch turns
     */
    switchTurn() {
        this.currentTurn = this.currentTurn === Turn.PLAYER ? Turn.COMPUTER : Turn.PLAYER;
    }

    getCellState(row, col) {
        return this.targetGrid[row][col];
    }

    getPlayerCellState(row, col) {
        return this.playerGrid[row][col];
    }
}

// =============================================================================
// RULES ENGINE
// =============================================================================

class RulesEngine {
    constructor() {
        this.gameMode = 'normal';
        this.updateLabels();
    }

    setGameMode(mode) {
        this.gameMode = mode;
        this.updateLabels();
    }

    updateLabels() {
        if (this.gameMode === 'advanced') {
            // Advanced mode (9x9): Full alphabet A-Z and digits 0-9
            // Rows: AB, CD, EF, GH, IJ, KL, MN, OP, QR (uses A-R)
            // Cols: S0, T1, U2, V3, W4, X5, Y6, Z7, 89 (uses S-Z + 0-9)
            this.validRows = ['AB', 'CD', 'EF', 'GH', 'IJ', 'KL', 'MN', 'OP', 'QR'];
            this.validCols = ['S0', 'T1', 'U2', 'V3', 'W4', 'X5', 'Y6', 'Z7', '89'];
        } else {
            // Normal mode (7x7): single letter rows (A-G), single digit columns (1-7)
            this.validRows = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
            this.validCols = ['1', '2', '3', '4', '5', '6', '7'];
        }
    }

    parseCoordinate(input) {
        if (!input) {
            return null;
        }

        const normalized = input.toUpperCase().trim();

        if (this.gameMode === 'advanced') {
            // Advanced mode: expect 4 characters (2 letters + 2 digits)
            if (normalized.length < 4) {
                return null;
            }
            const rowPart = normalized.substring(0, 2);
            const colPart = normalized.substring(2, 4);

            const rowIndex = this.validRows.indexOf(rowPart);
            const colIndex = this.validCols.indexOf(colPart);

            if (rowIndex === -1 || colIndex === -1) {
                return null;
            }

            return { row: rowIndex, col: colIndex };
        } else {
            // Normal mode: expect 2 characters (1 letter + 1 digit)
            if (normalized.length < 2) {
                return null;
            }
            const letter = normalized.charAt(0);
            const number = normalized.charAt(1);

            const rowIndex = this.validRows.indexOf(letter);
            const colIndex = this.validCols.indexOf(number);

            if (rowIndex === -1 || colIndex === -1) {
                return null;
            }

            return { row: rowIndex, col: colIndex };
        }
    }

    formatCoordinate(row, col) {
        return this.validRows[row] + this.validCols[col];
    }

    getResponseMeaning(response) {
        switch (response) {
            case 'S': return i18n.t('shipHit');
            case 'K': return i18n.t('shipSunk');
            case 'W': return i18n.t('waterMiss');
            case '?': return i18n.t('invalidCoord');
            default: return 'Unknown';
        }
    }
}

// =============================================================================
// GAME UI
// =============================================================================

class GameUI {
    constructor(game) {
        this.game = game;
        this.initElements();
        this.createGrids();
    }

    initElements() {
        this.elements = {
            // Grids
            targetGrid: document.getElementById('target-grid'),
            playerGrid: document.getElementById('player-grid'),

            // Stats
            playerShipsRemaining: document.getElementById('player-ships-remaining'),
            enemyShipsRemaining: document.getElementById('enemy-ships-remaining'),
            shotsFired: document.getElementById('shots-fired'),

            // Turn indicator
            turnIndicator: document.getElementById('turn-indicator'),

            // Morse input
            currentSignal: document.getElementById('current-signal'),
            currentChar: document.getElementById('current-char'),
            decodedInput: document.getElementById('decoded-input'),
            morseKey: document.getElementById('morse-key'),
            signalIndicator: document.getElementById('signal-indicator'),
            sendBtn: document.getElementById('send-btn'),
            clearBtn: document.getElementById('clear-btn'),
            newGameBtn: document.getElementById('new-game-btn'),

            // Response
            lastCoord: document.getElementById('last-coord'),
            responseChar: document.getElementById('response-char'),
            responseMeaning: document.getElementById('response-meaning'),

            // Last shot display
            lastShotDisplay: document.getElementById('last-shot-display'),

            // Placement UI
            placementUI: document.getElementById('placement-ui'),
            shipQueue: document.getElementById('ship-queue'),
            placementStatus: document.getElementById('placement-status'),
            rotateBtn: document.getElementById('rotate-btn'),
            randomBtn: document.getElementById('random-btn'),
            confirmFleetBtn: document.getElementById('confirm-fleet-btn')
        };
    }

    createGrids() {
        this.gridSize = this.game.gameState.gridSize;
        this.createTargetGrid();
        this.createPlayerGrid();
    }

    recreateGrids(gridSize) {
        this.gridSize = gridSize;

        // Update grid CSS for new size
        const gridStyle = `repeat(${gridSize}, 1fr)`;
        this.elements.targetGrid.style.gridTemplateColumns = gridStyle;
        this.elements.targetGrid.style.gridTemplateRows = gridStyle;
        this.elements.playerGrid.style.gridTemplateColumns = gridStyle;
        this.elements.playerGrid.style.gridTemplateRows = gridStyle;

        // Recreate grid cells
        this.createTargetGrid();
        this.createPlayerGrid();

        // Recreate labels
        this.recreateGridLabels(gridSize);
    }

    recreateGridLabels(gridSize) {
        // Recreate player grid labels
        const playerLabelsLeft = document.getElementById('player-grid-labels-left');
        const playerLabelsTop = document.getElementById('player-grid-labels-top');
        const targetLabelsLeft = document.getElementById('target-grid-labels-left');
        const targetLabelsTop = document.getElementById('target-grid-labels-top');

        // Clear and recreate row labels (left)
        playerLabelsLeft.innerHTML = '';
        targetLabelsLeft.innerHTML = '';
        for (let i = 0; i < gridSize; i++) {
            playerLabelsLeft.appendChild(document.createElement('span'));
            targetLabelsLeft.appendChild(document.createElement('span'));
        }

        // Clear and recreate column labels (top) - first span is empty corner
        playerLabelsTop.innerHTML = '<span></span>';
        targetLabelsTop.innerHTML = '<span></span>';
        for (let i = 0; i < gridSize; i++) {
            playerLabelsTop.appendChild(document.createElement('span'));
            targetLabelsTop.appendChild(document.createElement('span'));
        }

        // Update top labels grid template
        const topLabelStyle = `28px repeat(${gridSize}, 1fr)`;
        playerLabelsTop.style.gridTemplateColumns = topLabelStyle;
        targetLabelsTop.style.gridTemplateColumns = topLabelStyle;
    }

    createTargetGrid() {
        const gridSize = this.gridSize || 7;
        this.elements.targetGrid.innerHTML = '';
        this.targetCells = [];

        for (let row = 0; row < gridSize; row++) {
            this.targetCells[row] = [];
            for (let col = 0; col < gridSize; col++) {
                const cell = document.createElement('div');
                cell.className = 'cell unknown';
                cell.dataset.row = row;
                cell.dataset.col = col;
                this.elements.targetGrid.appendChild(cell);
                this.targetCells[row][col] = cell;
            }
        }

        // For backwards compatibility
        this.cells = this.targetCells;
    }

    createPlayerGrid() {
        const gridSize = this.gridSize || 7;
        this.elements.playerGrid.innerHTML = '';
        this.playerCells = [];

        for (let row = 0; row < gridSize; row++) {
            this.playerCells[row] = [];
            for (let col = 0; col < gridSize; col++) {
                const cell = document.createElement('div');
                cell.className = 'cell unknown';
                cell.dataset.row = row;
                cell.dataset.col = col;
                this.elements.playerGrid.appendChild(cell);
                this.playerCells[row][col] = cell;
            }
        }
    }

    updateGridLabels(rules) {
        const rowLabels = rules.validRows;
        const colLabels = rules.validCols;

        // Update player grid labels
        const playerLabelsLeft = document.getElementById('player-grid-labels-left');
        const playerLabelsTop = document.getElementById('player-grid-labels-top');

        // Update target grid labels
        const targetLabelsLeft = document.getElementById('target-grid-labels-left');
        const targetLabelsTop = document.getElementById('target-grid-labels-top');

        // Update row labels (left side)
        const playerLeftSpans = playerLabelsLeft.querySelectorAll('span');
        const targetLeftSpans = targetLabelsLeft.querySelectorAll('span');
        for (let i = 0; i < rowLabels.length; i++) {
            if (playerLeftSpans[i]) playerLeftSpans[i].textContent = rowLabels[i];
            if (targetLeftSpans[i]) targetLeftSpans[i].textContent = rowLabels[i];
        }

        // Update column labels (top row) - skip first empty span
        const playerTopSpans = playerLabelsTop.querySelectorAll('span');
        const targetTopSpans = targetLabelsTop.querySelectorAll('span');
        for (let i = 0; i < colLabels.length; i++) {
            if (playerTopSpans[i + 1]) playerTopSpans[i + 1].textContent = colLabels[i];
            if (targetTopSpans[i + 1]) targetTopSpans[i + 1].textContent = colLabels[i];
        }
    }

    updateMorseReference(mode) {
        const refLetters = document.getElementById('ref-letters');
        const refNumbers = document.getElementById('ref-numbers');

        if (mode === 'advanced') {
            // Advanced mode (9x9): Full alphabet A-Z and 0-9
            refLetters.innerHTML = `
                <h4 data-i18n="lettersAdvanced">${i18n.t('lettersAdvanced')}</h4>
                <div class="ref-item"><span>A</span><span>.-</span></div>
                <div class="ref-item"><span>B</span><span>-...</span></div>
                <div class="ref-item"><span>C</span><span>-.-.</span></div>
                <div class="ref-item"><span>D</span><span>-..</span></div>
                <div class="ref-item"><span>E</span><span>.</span></div>
                <div class="ref-item"><span>F</span><span>..-.</span></div>
                <div class="ref-item"><span>G</span><span>--.</span></div>
                <div class="ref-item"><span>H</span><span>....</span></div>
                <div class="ref-item"><span>I</span><span>..</span></div>
                <div class="ref-item"><span>J</span><span>.---</span></div>
                <div class="ref-item"><span>K</span><span>-.-</span></div>
                <div class="ref-item"><span>L</span><span>.-..</span></div>
                <div class="ref-item"><span>M</span><span>--</span></div>
                <div class="ref-item"><span>N</span><span>-.</span></div>
                <div class="ref-item"><span>O</span><span>---</span></div>
                <div class="ref-item"><span>P</span><span>.--.</span></div>
                <div class="ref-item"><span>Q</span><span>--.-</span></div>
                <div class="ref-item"><span>R</span><span>.-.</span></div>
                <div class="ref-item"><span>S</span><span>...</span></div>
                <div class="ref-item"><span>T</span><span>-</span></div>
                <div class="ref-item"><span>U</span><span>..-</span></div>
                <div class="ref-item"><span>V</span><span>...-</span></div>
                <div class="ref-item"><span>W</span><span>.--</span></div>
                <div class="ref-item"><span>X</span><span>-..-</span></div>
                <div class="ref-item"><span>Y</span><span>-.--</span></div>
                <div class="ref-item"><span>Z</span><span>--..</span></div>
            `;
            refNumbers.innerHTML = `
                <h4 data-i18n="numbersAdvanced">${i18n.t('numbersAdvanced')}</h4>
                <div class="ref-item"><span>0</span><span>-----</span></div>
                <div class="ref-item"><span>1</span><span>.----</span></div>
                <div class="ref-item"><span>2</span><span>..---</span></div>
                <div class="ref-item"><span>3</span><span>...--</span></div>
                <div class="ref-item"><span>4</span><span>....-</span></div>
                <div class="ref-item"><span>5</span><span>.....</span></div>
                <div class="ref-item"><span>6</span><span>-....</span></div>
                <div class="ref-item"><span>7</span><span>--...</span></div>
                <div class="ref-item"><span>8</span><span>---..</span></div>
                <div class="ref-item"><span>9</span><span>----.</span></div>
            `;
        } else {
            // Normal mode: A-G for rows, 1-7 for columns
            refLetters.innerHTML = `
                <h4 data-i18n="letters">${i18n.t('letters')}</h4>
                <div class="ref-item"><span>A</span><span>.-</span></div>
                <div class="ref-item"><span>B</span><span>-...</span></div>
                <div class="ref-item"><span>C</span><span>-.-.</span></div>
                <div class="ref-item"><span>D</span><span>-..</span></div>
                <div class="ref-item"><span>E</span><span>.</span></div>
                <div class="ref-item"><span>F</span><span>..-.</span></div>
                <div class="ref-item"><span>G</span><span>--.</span></div>
            `;
            refNumbers.innerHTML = `
                <h4 data-i18n="numbers">${i18n.t('numbers')}</h4>
                <div class="ref-item"><span>1</span><span>.----</span></div>
                <div class="ref-item"><span>2</span><span>..---</span></div>
                <div class="ref-item"><span>3</span><span>...--</span></div>
                <div class="ref-item"><span>4</span><span>....-</span></div>
                <div class="ref-item"><span>5</span><span>.....</span></div>
                <div class="ref-item"><span>6</span><span>-....</span></div>
                <div class="ref-item"><span>7</span><span>--...</span></div>
            `;
        }
    }

    updateTargetCell(row, col, state) {
        const cell = this.targetCells[row][col];
        cell.className = 'cell ' + state;
    }

    updatePlayerCell(row, col, state) {
        const cell = this.playerCells[row][col];
        cell.className = 'cell ' + state;
    }

    // For backwards compatibility
    updateCell(row, col, state) {
        this.updateTargetCell(row, col, state);
    }

    updateTargetGrid() {
        const gridSize = this.gridSize || 7;
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                const state = this.game.gameState.getCellState(row, col);
                this.updateTargetCell(row, col, state);
            }
        }
    }

    updatePlayerGrid() {
        const gridSize = this.gridSize || 7;
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                const state = this.game.gameState.getPlayerCellState(row, col);
                this.updatePlayerCell(row, col, state);
            }
        }
    }

    // For backwards compatibility
    updateGrid() {
        this.updateTargetGrid();
    }

    updateBothGrids() {
        this.updateTargetGrid();
        this.updatePlayerGrid();
    }

    updateStats() {
        this.elements.playerShipsRemaining.textContent = this.game.gameState.playerShipsRemaining;
        this.elements.enemyShipsRemaining.textContent = this.game.gameState.enemyShipsRemaining;
        this.elements.shotsFired.textContent = this.game.gameState.shotsFired;
    }

    updateTurnIndicator() {
        const indicator = this.elements.turnIndicator;
        const gameState = this.game.gameState;

        indicator.classList.remove('placement-phase', 'player-turn', 'computer-turn');

        if (gameState.phase === GamePhase.PLACEMENT) {
            indicator.classList.add('placement-phase');
            indicator.textContent = i18n.t('placeYourShips');
        } else if (gameState.phase === GamePhase.BATTLE) {
            if (gameState.currentTurn === Turn.PLAYER) {
                indicator.classList.add('player-turn');
                indicator.textContent = i18n.t('yourTurn');
            } else {
                indicator.classList.add('computer-turn');
                indicator.textContent = i18n.t('computerTurn');
            }
        } else if (gameState.phase === GamePhase.GAME_OVER) {
            if (gameState.winner === 'player') {
                indicator.classList.add('player-turn');
                indicator.textContent = i18n.t('victory', { shots: gameState.shotsFired });
            } else {
                indicator.classList.add('computer-turn');
                indicator.textContent = i18n.t('defeat');
            }
        }
    }

    updateMorseInput(state) {
        this.elements.currentSignal.textContent = state.isKeyDown ? 'ON' : 'OFF';
        this.elements.currentChar.textContent = state.currentSymbols || '-';
        this.elements.decodedInput.textContent = state.decodedChars || '-';

        if (state.isKeyDown) {
            this.elements.signalIndicator.classList.add('on');
            this.elements.morseKey.classList.add('active');
        } else {
            this.elements.signalIndicator.classList.remove('on');
            this.elements.morseKey.classList.remove('active');
        }
    }

    updateResponse(coord, response, meaning) {
        this.elements.lastCoord.textContent = coord || '-';
        this.elements.responseChar.textContent = response || '-';
        this.elements.responseMeaning.textContent = meaning || '-';
    }

    showLastEnemyShot(coord, result) {
        const display = this.elements.lastShotDisplay;
        display.style.display = 'block';
        display.classList.remove('hit', 'miss');

        const meaning = result === 'W' ? i18n.t('waterMiss') :
                       result === 'S' ? i18n.t('shipHit') :
                       result === 'K' ? i18n.t('shipSunk') : '';

        display.textContent = i18n.t('enemyFiredAt', { coord }) + ' - ' + meaning;
        display.classList.add(result === 'W' ? 'miss' : 'hit');
    }

    animateEnemyShot(row, col) {
        const cell = this.playerCells[row][col];
        cell.classList.add('last-shot');
        setTimeout(() => {
            cell.classList.remove('last-shot');
        }, 500);
    }

    // =========================================================================
    // PLACEMENT UI
    // =========================================================================

    showPlacementUI() {
        this.elements.placementUI.style.display = 'block';
        this.elements.sendBtn.disabled = true;
    }

    hidePlacementUI() {
        this.elements.placementUI.style.display = 'none';
        this.elements.sendBtn.disabled = false;
    }

    updateShipQueue(placementManager) {
        const queue = this.elements.shipQueue;
        queue.innerHTML = '';

        placementManager.shipQueue.forEach((ship, index) => {
            const item = document.createElement('div');
            item.className = 'ship-item';

            if (index < placementManager.currentIndex) {
                item.classList.add('placed');
            } else if (index === placementManager.currentIndex) {
                item.classList.add('current');
            }

            const name = i18n.t(ship.name);
            item.innerHTML = `
                <span>${name}</span>
                <div class="ship-cells">
                    ${Array(ship.size).fill('<div class="ship-cell-preview"></div>').join('')}
                </div>
            `;

            queue.appendChild(item);
        });
    }

    updatePlacementStatus(placementManager) {
        const status = this.elements.placementStatus;
        const ship = placementManager.getCurrentShip();

        if (ship) {
            const name = i18n.t(ship.name);
            status.textContent = i18n.t('placingShip', { ship: name, size: ship.size });
        } else {
            status.textContent = i18n.t('allShipsPlaced');
        }

        // Enable/disable confirm button
        this.elements.confirmFleetBtn.disabled = !placementManager.isPlacementComplete();
    }

    showPlacementPreview(cells, valid) {
        // Clear previous preview
        this.clearPlacementPreview();

        for (const cell of cells) {
            if (cell.row >= 0 && cell.row < 7 && cell.col >= 0 && cell.col < 7) {
                const gridCell = this.playerCells[cell.row][cell.col];
                gridCell.classList.add(valid ? 'placement-preview' : 'placement-invalid');
            }
        }
    }

    clearPlacementPreview() {
        for (let row = 0; row < 7; row++) {
            for (let col = 0; col < 7; col++) {
                this.playerCells[row][col].classList.remove('placement-preview', 'placement-invalid');
            }
        }
    }

    updatePlayerGridWithShips(placementManager) {
        // Clear grid
        for (let row = 0; row < 7; row++) {
            for (let col = 0; col < 7; col++) {
                this.playerCells[row][col].className = 'cell unknown';
            }
        }

        // Show placed ships
        const cells = placementManager.getPlacedShipCells();
        for (const cell of cells) {
            this.playerCells[cell.row][cell.col].className = 'cell ship';
        }
    }

    // =========================================================================
    // GAME OVER
    // =========================================================================

    showGameOverModal(winner, shots) {
        const overlay = document.createElement('div');
        overlay.className = 'game-over-overlay';
        overlay.id = 'game-over-overlay';

        const isVictory = winner === 'player';

        overlay.innerHTML = `
            <div class="game-over-modal ${isVictory ? '' : 'defeat'}">
                <h2>${isVictory ? i18n.t('victory', { shots }) : i18n.t('defeat')}</h2>
                <div class="game-over-stats">
                    <div class="game-over-stat">
                        <div class="value">${shots}</div>
                        <div class="label">${i18n.t('shotsFired')}</div>
                    </div>
                </div>
                <button class="btn" id="game-over-new-game">${i18n.t('newGame')}</button>
            </div>
        `;

        document.body.appendChild(overlay);

        document.getElementById('game-over-new-game').onclick = () => {
            this.hideGameOverModal();
            this.game.newGame();
        };
    }

    hideGameOverModal() {
        const overlay = document.getElementById('game-over-overlay');
        if (overlay) overlay.remove();
    }

    // Legacy method for backwards compatibility
    showGameOver() {
        this.showGameOverModal(this.game.gameState.winner, this.game.gameState.shotsFired);
        this.elements.sendBtn.disabled = true;
    }

    reset() {
        this.createGrids();
        this.updateStats();
        this.updateResponse(null, null, null);
        this.hideGameOverModal();
        this.elements.lastShotDisplay.style.display = 'none';
        this.elements.sendBtn.disabled = false;
        this.updateTurnIndicator();
    }
}

// =============================================================================
// MAIN GAME CONTROLLER
// =============================================================================

class MorseFleetGame {
    constructor() {
        this.audio = new MorseAudio();
        this.gameState = new GameState();
        this.rules = new RulesEngine();
        this.ui = new GameUI(this);
        this.computerAI = new ComputerAI(7);
        this.placementManager = new ShipPlacementManager(7);

        this.morseInput = new MorseInput(this.audio, (state) => {
            this.ui.updateMorseInput(state);
        });

        this.isProcessing = false;
        this.activeTouchId = null;

        this.bindEvents();
        this.ui.updateStats();

        // Start in placement phase
        this.startPlacementPhase();
    }

    // =========================================================================
    // GAME MODE
    // =========================================================================

    setGameMode(mode) {
        // Set game mode which updates grid size
        this.gameState.setGameMode(mode);
        this.rules.setGameMode(mode);

        // Get new grid size and ship configuration
        const gridSize = this.gameState.gridSize;
        const shipSizes = this.gameState.getShipSizes();

        // Update all components with new grid size
        this.computerAI.setGridSize(gridSize);
        this.placementManager.setConfig(gridSize, shipSizes);

        // Recreate grids with new size
        this.ui.recreateGrids(gridSize);
        this.ui.updateGridLabels(this.rules);
        this.ui.updateMorseReference(mode);

        // Reset the game state for new grid
        this.gameState.reset();
        this.ui.reset();

        // Restart placement phase
        this.startPlacementPhase();
    }

    // =========================================================================
    // PLACEMENT PHASE
    // =========================================================================

    startPlacementPhase() {
        this.placementManager.reset();
        this.ui.showPlacementUI();
        this.ui.updateShipQueue(this.placementManager);
        this.ui.updatePlacementStatus(this.placementManager);
        this.ui.updateTurnIndicator();
        this.bindPlacementEvents();

        // Re-enable mode selector during placement phase
        const modeSelect = document.getElementById('mode-select');
        if (modeSelect) modeSelect.disabled = false;
    }

    bindPlacementEvents() {
        const { playerGrid } = this.ui.elements;
        const { rotateBtn, randomBtn, confirmFleetBtn } = this.ui.elements;

        // Click on grid to place ship
        this.placementClickHandler = (e) => {
            const cell = e.target.closest('.cell');
            if (!cell) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            if (this.placementManager.placeShip(row, col)) {
                this.ui.updatePlayerGridWithShips(this.placementManager);
                this.ui.updateShipQueue(this.placementManager);
                this.ui.updatePlacementStatus(this.placementManager);
            }
        };

        // Hover on grid to show preview
        this.placementHoverHandler = (e) => {
            const cell = e.target.closest('.cell');
            if (!cell) {
                this.ui.clearPlacementPreview();
                return;
            }

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            const preview = this.placementManager.getPreview(row, col);
            this.ui.showPlacementPreview(preview.cells, preview.valid);
        };

        playerGrid.addEventListener('click', this.placementClickHandler);
        playerGrid.addEventListener('mousemove', this.placementHoverHandler);
        playerGrid.addEventListener('mouseleave', () => this.ui.clearPlacementPreview());

        // Rotate button
        rotateBtn.onclick = () => {
            this.placementManager.rotate();
        };

        // Random button
        randomBtn.onclick = () => {
            this.placementManager.placeRandomly();
            this.ui.updatePlayerGridWithShips(this.placementManager);
            this.ui.updateShipQueue(this.placementManager);
            this.ui.updatePlacementStatus(this.placementManager);
        };

        // Confirm fleet button
        confirmFleetBtn.onclick = () => {
            if (this.placementManager.isPlacementComplete()) {
                this.confirmFleet();
            }
        };

        // R key to rotate
        this.rotateKeyHandler = (e) => {
            if (e.code === 'KeyR' && this.gameState.phase === GamePhase.PLACEMENT) {
                this.placementManager.rotate();
            }
        };
        document.addEventListener('keydown', this.rotateKeyHandler);
    }

    unbindPlacementEvents() {
        const { playerGrid } = this.ui.elements;
        if (this.placementClickHandler) {
            playerGrid.removeEventListener('click', this.placementClickHandler);
        }
        if (this.placementHoverHandler) {
            playerGrid.removeEventListener('mousemove', this.placementHoverHandler);
        }
        if (this.rotateKeyHandler) {
            document.removeEventListener('keydown', this.rotateKeyHandler);
        }
    }

    confirmFleet() {
        // Set player ships in game state
        this.gameState.setPlayerShips(this.placementManager.getShips());

        // Unbind placement events
        this.unbindPlacementEvents();

        // Hide placement UI
        this.ui.hidePlacementUI();
        this.ui.clearPlacementPreview();

        // Disable mode selector during battle
        const modeSelect = document.getElementById('mode-select');
        if (modeSelect) modeSelect.disabled = true;

        // Start battle phase
        this.gameState.startBattle();
        this.ui.updateTurnIndicator();
        this.ui.updateStats();
        this.ui.updatePlayerGrid();
    }

    // =========================================================================
    // BATTLE PHASE - EVENT BINDING
    // =========================================================================

    bindEvents() {
        const { morseKey, sendBtn, clearBtn, newGameBtn } = this.ui.elements;

        // ===========================================
        // TOUCH EVENTS (Mobile/Tablet)
        // ===========================================

        morseKey.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();

            // Track first touch only
            if (this.activeTouchId === null && e.touches.length > 0) {
                this.activeTouchId = e.touches[0].identifier;

                if (this.canPlayerInput()) {
                    this.morseInput.keyDown();
                }
            }
        }, { passive: false });

        morseKey.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();

            // Check if our tracked touch ended
            let touchEnded = true;
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === this.activeTouchId) {
                    touchEnded = false;
                    break;
                }
            }

            if (touchEnded && this.activeTouchId !== null) {
                this.activeTouchId = null;
                this.morseInput.keyUp();
            }
        }, { passive: false });

        morseKey.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            this.activeTouchId = null;
            this.morseInput.keyUp();
        }, { passive: false });

        // Prevent context menu on long press
        morseKey.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // ===========================================
        // MOUSE EVENTS (Desktop)
        // ===========================================

        morseKey.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (this.canPlayerInput()) {
                this.morseInput.keyDown();
            }
        });

        morseKey.addEventListener('mouseup', (e) => {
            e.preventDefault();
            this.morseInput.keyUp();
        });

        morseKey.addEventListener('mouseleave', () => {
            if (this.morseInput.isKeyDown) {
                this.morseInput.keyUp();
            }
        });

        // ===========================================
        // KEYBOARD EVENTS (Spacebar)
        // ===========================================

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                if (this.canPlayerInput()) {
                    this.morseInput.keyDown();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                this.morseInput.keyUp();
            }
        });

        // ===========================================
        // BUTTON EVENTS
        // ===========================================

        sendBtn.addEventListener('click', () => this.sendCoordinate());
        clearBtn.addEventListener('click', () => this.clearInput());
        newGameBtn.addEventListener('click', () => this.newGame());

        // Prevent zoom on double-tap for buttons
        [sendBtn, clearBtn, newGameBtn].forEach(btn => {
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                btn.click();
            }, { passive: false });
        });
    }

    /**
     * Check if player can input (during battle phase, player's turn, not processing)
     */
    canPlayerInput() {
        return this.gameState.phase === GamePhase.BATTLE &&
               this.gameState.currentTurn === Turn.PLAYER &&
               !this.isProcessing &&
               !this.gameState.isGameOver;
    }

    // =========================================================================
    // BATTLE PHASE - PLAYER'S TURN
    // =========================================================================

    async sendCoordinate() {
        if (!this.canPlayerInput()) return;

        this.morseInput.finalize();
        await new Promise(resolve => setTimeout(resolve, 100));

        const input = this.morseInput.getDecodedInput();

        if (!input) {
            await this.respondWithMorse('?', 'No input received');
            return;
        }

        const coord = this.rules.parseCoordinate(input);

        if (!coord) {
            await this.respondWithMorse('?', 'Invalid: ' + input);
            return;
        }

        const response = this.gameState.processShot(coord.row, coord.col);
        const coordStr = this.rules.formatCoordinate(coord.row, coord.col);
        const meaning = this.rules.getResponseMeaning(response);

        this.ui.updateTargetGrid();
        this.ui.updateStats();

        await this.respondWithMorse(response, meaning, coordStr);

        this.morseInput.clear();

        // Check for game over
        if (this.gameState.isGameOver) {
            this.ui.updateTurnIndicator();
            this.ui.showGameOver();
            return;
        }

        // Switch to computer's turn
        this.gameState.switchTurn();
        this.ui.updateTurnIndicator();

        // Execute computer's turn after a delay
        setTimeout(() => this.executeComputerTurn(), 1500);
    }

    async respondWithMorse(response, meaning, coord = null) {
        this.isProcessing = true;

        this.ui.updateResponse(coord || '-', response, meaning);
        await this.audio.playChar(response);

        this.isProcessing = false;
    }

    // =========================================================================
    // BATTLE PHASE - COMPUTER'S TURN
    // =========================================================================

    async executeComputerTurn() {
        if (this.gameState.phase !== GamePhase.BATTLE ||
            this.gameState.currentTurn !== Turn.COMPUTER) {
            return;
        }

        this.isProcessing = true;

        // Get computer's shot
        const shot = this.computerAI.getNextShot();
        if (!shot) {
            // No valid shots - shouldn't happen
            this.isProcessing = false;
            return;
        }

        const coordStr = this.rules.formatCoordinate(shot.row, shot.col);

        // Process the shot
        const result = this.gameState.processComputerShot(shot.row, shot.col);

        if (result === null) {
            // Invalid shot - try again
            this.isProcessing = false;
            this.executeComputerTurn();
            return;
        }

        // Record result for AI
        this.computerAI.recordShot(shot.row, shot.col, result);

        // Update UI
        this.ui.animateEnemyShot(shot.row, shot.col);
        this.ui.updatePlayerGrid();
        this.ui.updateStats();
        this.ui.showLastEnemyShot(coordStr, result);

        // Play response morse
        await this.audio.playChar(result);

        this.isProcessing = false;

        // Check for game over
        if (this.gameState.isGameOver) {
            this.ui.updateTurnIndicator();
            this.ui.showGameOver();
            return;
        }

        // Switch back to player's turn
        this.gameState.switchTurn();
        this.ui.updateTurnIndicator();
    }

    // =========================================================================
    // UTILITY METHODS
    // =========================================================================

    clearInput() {
        this.morseInput.clear();
    }

    newGame() {
        this.gameState.reset();
        this.computerAI.reset();
        this.placementManager.reset();
        this.morseInput.clear();
        this.ui.reset();
        this.isProcessing = false;

        // Restart placement phase
        this.startPlacementPhase();
    }
}

// =============================================================================
// TUTORIAL MODE
// =============================================================================

/**
 * Interactive tutorial that demonstrates Morse code input
 * Shows animated key presses and timing
 */
const Tutorial = {
    overlay: null,
    isRunning: false,
    abortController: null,

    /**
     * Show the tutorial modal
     */
    show() {
        this.remove();

        this.overlay = document.createElement('div');
        this.overlay.className = 'tutorial-overlay';
        this.overlay.innerHTML = `
            <div class="tutorial-modal">
                <div class="tutorial-header">
                    <h2>${i18n.t('tutorialTitle')}</h2>
                    <button class="tutorial-close">&times;</button>
                </div>
                <div class="tutorial-content">
                    <div class="tutorial-step">
                        <div class="tutorial-step-header">
                            <span class="tutorial-step-num">1</span>
                            <h3>${i18n.t('tutorialStep1Title')}</h3>
                        </div>
                        <p>${i18n.t('tutorialStep1Text')}</p>
                        <div class="timing-diagram">
                            <div>
                                <div class="timing-dot"></div>
                                <div class="timing-label">${i18n.t('dot')}<br>&lt;200ms</div>
                            </div>
                            <div class="timing-gap"></div>
                            <div>
                                <div class="timing-dash"></div>
                                <div class="timing-label">${i18n.t('dash')}<br>&gt;200ms</div>
                            </div>
                        </div>
                    </div>

                    <div class="tutorial-step">
                        <div class="tutorial-step-header">
                            <span class="tutorial-step-num">2</span>
                            <h3>${i18n.t('tutorialStep2Title')}</h3>
                        </div>
                        <p>${i18n.t('tutorialStep2Text')}</p>
                    </div>

                    <div class="tutorial-step">
                        <div class="tutorial-step-header">
                            <span class="tutorial-step-num">3</span>
                            <h3>${i18n.t('tutorialStep3Title')}</h3>
                        </div>
                        <p>${i18n.t('tutorialStep3Text')}</p>
                    </div>

                    <div class="tutorial-step">
                        <div class="tutorial-step-header">
                            <span class="tutorial-step-num">4</span>
                            <h3>${i18n.t('tutorialStep4Title')}</h3>
                        </div>
                        <p>${i18n.t('tutorialStep4Text')}</p>
                        <p style="color: var(--accent-success); font-family: monospace;">
                            A = .-  &nbsp;&nbsp; 1 = .----
                        </p>

                        <div class="tutorial-demo">
                            <div class="demo-key" id="demo-key">${i18n.t('morseKey')}</div>
                            <div class="demo-indicator" id="demo-indicator"></div>
                            <div class="demo-output" id="demo-output"></div>
                            <div class="demo-decoded" id="demo-decoded"></div>
                        </div>
                    </div>

                    <div class="tutorial-controls">
                        <button class="tutorial-btn-demo" id="demo-start-btn">
                            ${i18n.t('playDemo')}
                        </button>
                    </div>

                    <div class="tutorial-step" style="margin-top: 20px;">
                        <div class="tutorial-step-header">
                            <span class="tutorial-step-num">5</span>
                            <h3>${i18n.t('tutorialStep5Title')}</h3>
                        </div>
                        <p>${i18n.t('tutorialStep5Text')}</p>
                        <p style="font-family: monospace; color: var(--text-primary);">
                            <span style="color: var(--accent-primary);">W (.--)</span> = ${i18n.t('waterMiss')}<br>
                            <span style="color: var(--accent-danger);">S (...)</span> = ${i18n.t('shipHit')}<br>
                            <span style="color: var(--accent-warning);">K (-.-)</span> = ${i18n.t('shipSunk')}
                        </p>
                    </div>

                    <div class="tutorial-step" style="margin-bottom: 0;">
                        <div class="tutorial-step-header">
                            <span class="tutorial-step-num">6</span>
                            <h3>${i18n.t('tutorialStep6Title')}</h3>
                        </div>
                        <p>${i18n.t('tutorialStep6Text')}</p>
                        <div class="tutorial-controls" style="border: none; padding-top: 10px; margin-top: 10px;">
                            <button class="tutorial-btn-demo" id="autoplay-btn" style="background: var(--accent-success);">
                                ${i18n.t('autoplayGame')}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(this.overlay);
        this.setupHandlers();
    },

    /**
     * Setup event handlers
     */
    setupHandlers() {
        const closeBtn = this.overlay.querySelector('.tutorial-close');
        const demoBtn = this.overlay.querySelector('#demo-start-btn');
        const autoplayBtn = this.overlay.querySelector('#autoplay-btn');

        closeBtn.onclick = () => this.remove();

        this.overlay.onclick = (e) => {
            if (e.target === this.overlay) this.remove();
        };

        demoBtn.onclick = () => this.runDemo();
        autoplayBtn.onclick = () => this.startAutoplay();

        // ESC to close
        this.escHandler = (e) => {
            if (e.key === 'Escape') this.remove();
        };
        document.addEventListener('keydown', this.escHandler);
    },

    /**
     * Remove tutorial modal
     */
    remove() {
        if (this.abortController) {
            this.abortController.abort();
            this.abortController = null;
        }
        if (this.overlay) {
            this.overlay.remove();
            this.overlay = null;
        }
        if (this.escHandler) {
            document.removeEventListener('keydown', this.escHandler);
            this.escHandler = null;
        }
        this.isRunning = false;
    },

    /**
     * Run the demo animation showing how to key "A1"
     */
    async runDemo() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.abortController = new AbortController();

        const demoKey = document.getElementById('demo-key');
        const demoIndicator = document.getElementById('demo-indicator');
        const demoOutput = document.getElementById('demo-output');
        const demoDecoded = document.getElementById('demo-decoded');
        const demoBtn = document.getElementById('demo-start-btn');

        if (!demoKey) return;

        demoBtn.disabled = true;
        demoBtn.textContent = i18n.t('playing');

        // Clear previous
        demoOutput.textContent = '';
        demoDecoded.textContent = '';

        // Create audio context for demo
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const playTone = async (duration) => {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();

            // Visual feedback
            demoKey.classList.add('active');
            demoIndicator.classList.add('on');

            await this.sleep(duration);

            oscillator.stop();
            demoKey.classList.remove('active');
            demoIndicator.classList.remove('on');
        };

        try {
            const timing = MorseTiming.get();
            const dot = timing.OUT_DOT;
            const dash = timing.OUT_DASH;
            const intra = timing.OUT_INTRA;
            const charGap = timing.CHAR_GAP;

            // A = .- (dot dash)
            // Dot
            await playTone(dot);
            demoOutput.textContent = '.';
            await this.sleep(intra);

            // Dash
            await playTone(dash);
            demoOutput.textContent = '.-';
            await this.sleep(charGap + 50);

            // Character decoded
            demoDecoded.textContent = 'A';
            demoOutput.textContent = '';
            await this.sleep(500);

            // 1 = .---- (dot dash dash dash dash)
            // Dot
            await playTone(dot);
            demoOutput.textContent = '.';
            await this.sleep(intra);

            // Dash 1
            await playTone(dash);
            demoOutput.textContent = '.-';
            await this.sleep(intra);

            // Dash 2
            await playTone(dash);
            demoOutput.textContent = '.--';
            await this.sleep(intra);

            // Dash 3
            await playTone(dash);
            demoOutput.textContent = '.---';
            await this.sleep(intra);

            // Dash 4
            await playTone(dash);
            demoOutput.textContent = '.----';
            await this.sleep(charGap + 50);

            // Character decoded
            demoDecoded.textContent = 'A1';
            demoOutput.textContent = i18n.t('readyToSend');
            demoOutput.style.color = 'var(--accent-success)';

            await this.sleep(1500);
            demoOutput.style.color = '';
            demoOutput.textContent = '';

        } catch (e) {
            // Aborted
        }

        audioCtx.close();

        demoBtn.disabled = false;
        demoBtn.textContent = i18n.t('playDemo');
        this.isRunning = false;
    },

    /**
     * Sleep helper
     */
    sleep(ms) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(resolve, ms);
            if (this.abortController) {
                this.abortController.signal.addEventListener('abort', () => {
                    clearTimeout(timeout);
                    reject(new Error('Aborted'));
                });
            }
        });
    },

    /**
     * Start autoplay mode - closes tutorial and plays the game automatically
     */
    startAutoplay() {
        this.remove();
        Autoplay.start();
    },

    /**
     * Initialize tutorial button
     */
    init() {
        const tutorialBtn = document.getElementById('tutorial-btn');
        if (tutorialBtn) {
            tutorialBtn.onclick = () => this.show();
        }
    }
};

// =============================================================================
// AUTOPLAY MODE
// =============================================================================

/**
 * Autoplay mode - automatically plays the game by simulating Morse key input
 * Demonstrates the full game loop including computer responses
 */
const Autoplay = {
    isRunning: false,
    abortController: null,
    statusEl: null,

    /**
     * Morse code patterns for coordinates (dot=0, dash=1)
     * Full alphabet A-Z and digits 0-9 for advanced mode
     */
    morsePatterns: {
        // Full alphabet A-Z
        'A': [0, 1],           // .-
        'B': [1, 0, 0, 0],     // -...
        'C': [1, 0, 1, 0],     // -.-.
        'D': [1, 0, 0],        // -..
        'E': [0],              // .
        'F': [0, 0, 1, 0],     // ..-.
        'G': [1, 1, 0],        // --.
        'H': [0, 0, 0, 0],     // ....
        'I': [0, 0],           // ..
        'J': [0, 1, 1, 1],     // .---
        'K': [1, 0, 1],        // -.-
        'L': [0, 1, 0, 0],     // .-..
        'M': [1, 1],           // --
        'N': [1, 0],           // -.
        'O': [1, 1, 1],        // ---
        'P': [0, 1, 1, 0],     // .--.
        'Q': [1, 1, 0, 1],     // --.-
        'R': [0, 1, 0],        // .-.
        'S': [0, 0, 0],        // ...
        'T': [1],              // -
        'U': [0, 0, 1],        // ..-
        'V': [0, 0, 0, 1],     // ...-
        'W': [0, 1, 1],        // .--
        'X': [1, 0, 0, 1],     // -..-
        'Y': [1, 0, 1, 1],     // -.--
        'Z': [1, 1, 0, 0],     // --..
        // Numbers 0-9
        '0': [1, 1, 1, 1, 1],  // -----
        '1': [0, 1, 1, 1, 1],  // .----
        '2': [0, 0, 1, 1, 1],  // ..---
        '3': [0, 0, 0, 1, 1],  // ...--
        '4': [0, 0, 0, 0, 1],  // ....-
        '5': [0, 0, 0, 0, 0],  // .....
        '6': [1, 0, 0, 0, 0],  // -....
        '7': [1, 1, 0, 0, 0],  // --...
        '8': [1, 1, 1, 0, 0],  // ---..
        '9': [1, 1, 1, 1, 0]   // ----.
    },

    /**
     * Get duration for a morse element based on current WPM
     */
    getDuration(isDash) {
        const timing = MorseTiming.get();
        return isDash ? timing.OUT_DASH : timing.OUT_DOT;
    },

    /**
     * Start autoplay mode
     */
    start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.abortController = new AbortController();

        // Create status overlay
        this.createStatusOverlay();

        // Start new game and auto-place ships
        if (window.game) {
            window.game.newGame();

            // Auto-place ships randomly
            window.game.placementManager.placeRandomly();
            window.game.ui.updatePlayerGridWithShips(window.game.placementManager);
            window.game.ui.updateShipQueue(window.game.placementManager);
            window.game.ui.updatePlacementStatus(window.game.placementManager);

            // Confirm fleet to start battle
            window.game.confirmFleet();
        }

        this.playGame();
    },

    /**
     * Stop autoplay mode
     */
    stop() {
        this.isRunning = false;
        if (this.abortController) {
            this.abortController.abort();
            this.abortController = null;
        }
        this.removeStatusOverlay();
    },

    /**
     * Create status overlay showing autoplay info
     */
    createStatusOverlay() {
        this.removeStatusOverlay();

        this.statusEl = document.createElement('div');
        this.statusEl.id = 'autoplay-status';
        this.statusEl.style.cssText = `
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(34, 197, 94, 0.95);
            color: var(--bg-primary);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            z-index: 999;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        `;
        this.statusEl.innerHTML = `
            <span class="autoplay-dot" style="
                width: 10px;
                height: 10px;
                background: var(--accent-danger);
                border-radius: 50%;
                animation: autoplay-pulse 1s infinite;
            "></span>
            <span id="autoplay-text"></span>
            <button id="autoplay-stop" style="
                background: var(--accent-danger);
                color: white;
                border: none;
                padding: 5px 12px;
                border-radius: 10px;
                cursor: pointer;
                font-size: 0.85em;
                margin-left: 10px;
            ">${i18n.t('stop')}</button>
        `;

        // Add pulse animation
        const style = document.createElement('style');
        style.id = 'autoplay-style';
        style.textContent = `
            @keyframes autoplay-pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.3; }
            }
        `;
        document.head.appendChild(style);

        document.body.appendChild(this.statusEl);

        // Set initial status text
        this.updateStatus(i18n.t('autoplayStarting'));

        // Stop button handler
        document.getElementById('autoplay-stop').onclick = () => this.stop();
    },

    /**
     * Remove status overlay
     */
    removeStatusOverlay() {
        if (this.statusEl) {
            this.statusEl.remove();
            this.statusEl = null;
        }
        const style = document.getElementById('autoplay-style');
        if (style) style.remove();
    },

    /**
     * Update status text
     */
    updateStatus(text) {
        const el = document.getElementById('autoplay-text');
        if (el) el.textContent = i18n.t('autoplay') + ': ' + text;
    },

    /**
     * Play the game automatically
     */
    async playGame() {
        const game = window.game;
        if (!game) {
            this.stop();
            return;
        }

        // Get coordinate labels from the rules engine (supports both normal and advanced modes)
        const rows = game.rules.validRows;
        const cols = game.rules.validCols;

        // Generate random order of coordinates
        const coords = [];
        for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
            for (let colIdx = 0; colIdx < cols.length; colIdx++) {
                coords.push({ row: rowIdx, col: colIdx, label: rows[rowIdx] + cols[colIdx] });
            }
        }
        // Shuffle
        for (let i = coords.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [coords[i], coords[j]] = [coords[j], coords[i]];
        }

        try {
            for (const coordInfo of coords) {
                if (!this.isRunning || game.gameState.isGameOver) break;

                // Wait for player's turn
                while (game.gameState.currentTurn !== Turn.PLAYER &&
                       game.gameState.phase === GamePhase.BATTLE &&
                       !game.gameState.isGameOver) {
                    await this.sleep(200);
                    if (!this.isRunning) break;
                }

                if (!this.isRunning || game.gameState.isGameOver) break;

                this.updateStatus(i18n.t('autoplayFiring', { coord: coordInfo.label }));

                // Check if already hit
                const row = coordInfo.row;
                const col = coordInfo.col;
                if (game.gameState.getCellState(row, col) !== 'unknown') {
                    continue;
                }

                // Send the coordinate via Morse
                await this.sendCoordinate(coordInfo.label, game);

                if (!this.isRunning || game.gameState.isGameOver) break;

                // Wait for computer's turn to complete
                await this.sleep(500);
                while (game.gameState.currentTurn !== Turn.PLAYER &&
                       game.gameState.phase === GamePhase.BATTLE &&
                       !game.gameState.isGameOver) {
                    await this.sleep(200);
                    if (!this.isRunning) break;
                }

                if (!this.isRunning) break;

                // Small delay before next player shot
                await this.sleep(1000);
            }

            if (game.gameState.isGameOver && this.isRunning) {
                const isVictory = game.gameState.winner === 'player';
                if (isVictory) {
                    this.updateStatus(i18n.t('autoplayVictory', { shots: game.gameState.shotsFired }));
                } else {
                    this.updateStatus(i18n.t('defeat'));
                }
                await this.sleep(3000);
            }

        } catch (e) {
            // Aborted
        }

        this.stop();
    },

    /**
     * Send a coordinate by simulating Morse key presses
     * Handles both normal mode (2 chars) and advanced mode (4 chars)
     */
    async sendCoordinate(coord, game) {
        // Clear any existing input
        game.morseInput.clear();

        const timing = MorseTiming.get();

        // Send all characters in the coordinate (e.g., "A1" or "AB01")
        for (let i = 0; i < coord.length; i++) {
            await this.sendCharacter(coord[i], game);
            if (i < coord.length - 1) {
                await this.sleep(timing.CHAR_GAP + 50); // Inter-character gap
            }
        }
        await this.sleep(timing.CHAR_GAP + 100); // Wait for last character to be decoded

        // Trigger send with visual feedback
        this.updateStatus(i18n.t('autoplaySending', { coord }));
        const sendBtn = document.getElementById('send-btn');
        if (sendBtn) {
            sendBtn.classList.add('pressed');
            await this.sleep(150);
        }
        await game.sendCoordinate();
        if (sendBtn) {
            sendBtn.classList.remove('pressed');
        }

        // Wait for response to play
        await this.sleep(500);
    },

    /**
     * Send a single character by simulating key presses
     */
    async sendCharacter(char, game) {
        const pattern = this.morsePatterns[char];
        if (!pattern) return;

        const timing = MorseTiming.get();
        for (let i = 0; i < pattern.length; i++) {
            const isDash = pattern[i] === 1;
            const duration = this.getDuration(isDash);

            // Key down
            game.morseInput.keyDown();
            await this.sleep(duration);

            // Key up
            game.morseInput.keyUp();

            // Gap between elements (except last)
            if (i < pattern.length - 1) {
                await this.sleep(timing.OUT_INTRA);
            }
        }
    },

    /**
     * Sleep helper with abort support
     */
    sleep(ms) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(resolve, ms);
            if (this.abortController) {
                this.abortController.signal.addEventListener('abort', () => {
                    clearTimeout(timeout);
                    reject(new Error('Aborted'));
                });
            }
        });
    }
};

// =============================================================================
// LEGAL MODALS (Imprint & Privacy)
// =============================================================================

/**
 * Imprint and Privacy modal functionality
 * Required by Austrian law (§ 5 ECG and § 25 MedienG)
 */
const LegalModals = {
    // Static operator data (not translated)
    operatorData: {
        name: 'Michael Linder',
        callsign: 'OE8YML',
        address: 'Nötsch 219, 9611 Nötsch',
        country: 'Österreich',
        email: 'oe8yml@rednil.at'
    },

    /**
     * Show imprint modal
     */
    showImprint() {
        this.removeExisting();
        const op = this.operatorData;

        const overlay = document.createElement('div');
        overlay.className = 'legal-modal-overlay';
        overlay.innerHTML = `
            <div class="legal-modal">
                <div class="legal-modal-header">
                    <h2>${i18n.t('imprintTitle')}</h2>
                    <button class="legal-modal-close">&times;</button>
                </div>
                <div class="legal-modal-content">
                    <p class="legal-info">${i18n.t('imprintInfo')}</p>

                    <div class="legal-section">
                        <h3>${i18n.t('imprintOperator')}</h3>
                        <div class="legal-address">
                            <p><strong>${op.name}</strong></p>
                            <p>${op.callsign}</p>
                            <p>${op.address}</p>
                            <p>${op.country}</p>
                        </div>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('imprintContact')}</h3>
                        <p><a href="mailto:${op.email}" class="legal-email">${op.email}</a></p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('imprintLiabilityTitle')}</h3>
                        <p>${i18n.t('imprintLiabilityText')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('imprintCopyrightTitle')}</h3>
                        <p>${i18n.t('imprintCopyrightText')}</p>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);
        this.setupCloseHandlers(overlay);
    },

    /**
     * Show privacy modal
     */
    showPrivacy() {
        this.removeExisting();

        const overlay = document.createElement('div');
        overlay.className = 'legal-modal-overlay';
        overlay.innerHTML = `
            <div class="legal-modal">
                <div class="legal-modal-header">
                    <h2>${i18n.t('privacyTitle')}</h2>
                    <button class="legal-modal-close">&times;</button>
                </div>
                <div class="legal-modal-content">
                    <div class="legal-section">
                        <h3>${i18n.t('privacyIntroTitle')}</h3>
                        <p>${i18n.t('privacyIntroText')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('privacyCollectionTitle')}</h3>
                        <p>${i18n.t('privacyCollectionText')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('privacyHostingTitle')}</h3>
                        <p>${i18n.t('privacyHostingText')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('privacyRightsTitle')}</h3>
                        <p>${i18n.t('privacyRightsText')}</p>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);
        this.setupCloseHandlers(overlay);
    },

    /**
     * Remove existing modal
     */
    removeExisting() {
        const existing = document.querySelector('.legal-modal-overlay');
        if (existing) existing.remove();
    },

    /**
     * Setup close handlers for modal
     */
    setupCloseHandlers(overlay) {
        // Close button
        const closeBtn = overlay.querySelector('.legal-modal-close');
        if (closeBtn) {
            closeBtn.onclick = () => overlay.remove();
        }

        // Click outside to close
        overlay.onclick = (e) => {
            if (e.target === overlay) overlay.remove();
        };

        // Escape key to close
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                overlay.remove();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
    },

    /**
     * Initialize footer links
     */
    init() {
        const imprintLink = document.getElementById('imprint-link');
        const privacyLink = document.getElementById('privacy-link');

        if (imprintLink) {
            imprintLink.onclick = (e) => {
                e.preventDefault();
                this.showImprint();
            };
        }

        if (privacyLink) {
            privacyLink.onclick = (e) => {
                e.preventDefault();
                this.showPrivacy();
            };
        }
    }
};

// =============================================================================
// HELP MODAL
// =============================================================================

/**
 * Help modal - Game instructions in all languages
 */
const HelpModal = {
    /**
     * Show help modal
     */
    show() {
        this.removeExisting();

        const overlay = document.createElement('div');
        overlay.className = 'legal-modal-overlay';
        overlay.innerHTML = `
            <div class="legal-modal">
                <div class="legal-modal-header">
                    <h2>${i18n.t('helpTitle')}</h2>
                    <button class="legal-modal-close">&times;</button>
                </div>
                <div class="legal-modal-content">
                    <p class="legal-info">${i18n.t('helpIntro')}</p>

                    <div class="legal-section">
                        <h3>${i18n.t('helpPhase1Title')}</h3>
                        <p>${i18n.t('helpPhase1Text')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('helpPhase2Title')}</h3>
                        <p>${i18n.t('helpPhase2Text')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('helpPhase3Title')}</h3>
                        <p>${i18n.t('helpPhase3Text')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('helpPhase4Title')}</h3>
                        <p>${i18n.t('helpPhase4Text')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('helpMorseTitle')}</h3>
                        <p style="font-family: monospace; color: var(--accent-success);">${i18n.t('helpMorseText')}</p>
                    </div>

                    <div class="legal-section">
                        <h3>${i18n.t('helpTipsTitle')}</h3>
                        <ul style="color: var(--text-primary); padding-left: 20px;">
                            <li>${i18n.t('helpTip1')}</li>
                            <li>${i18n.t('helpTip2')}</li>
                            <li>${i18n.t('helpTip3')}</li>
                            <li>${i18n.t('helpTip4')}</li>
                        </ul>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);
        this.setupCloseHandlers(overlay);
    },

    /**
     * Remove existing modal
     */
    removeExisting() {
        const existing = document.querySelector('.legal-modal-overlay');
        if (existing) existing.remove();
    },

    /**
     * Setup close handlers for modal
     */
    setupCloseHandlers(overlay) {
        // Close button
        const closeBtn = overlay.querySelector('.legal-modal-close');
        if (closeBtn) {
            closeBtn.onclick = () => overlay.remove();
        }

        // Click outside to close
        overlay.onclick = (e) => {
            if (e.target === overlay) overlay.remove();
        };

        // Escape key to close
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                overlay.remove();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
    },

    /**
     * Initialize help link
     */
    init() {
        const helpLink = document.getElementById('help-link');

        if (helpLink) {
            helpLink.onclick = (e) => {
                e.preventDefault();
                this.show();
            };
        }
    }
};

// =============================================================================
// SITE CONFIG (Parent Site Branding)
// =============================================================================

/**
 * Loads runtime configuration from config.json
 * Enables parent site branding without rebuilding
 */
const SiteConfig = {
    config: null,

    /**
     * Load config.json and apply branding
     */
    async init() {
        try {
            const response = await fetch('config.json');
            if (response.ok) {
                this.config = await response.json();
                this.applyBranding();
            }
        } catch (e) {
            // Config not available, that's fine
            console.log('No config.json found, using defaults');
        }
    },

    /**
     * Apply parent site branding to header and footer
     */
    applyBranding() {
        if (!this.config) return;

        const { parentSiteUrl, parentSiteLogo, parentSiteName } = this.config;

        // Header logo
        if (parentSiteLogo && parentSiteUrl) {
            const logoLink = document.getElementById('parent-logo-link');
            const logoImg = document.getElementById('parent-logo-img');
            if (logoLink && logoImg) {
                logoLink.href = parentSiteUrl;
                logoImg.src = parentSiteLogo;
                logoImg.alt = parentSiteName || 'Parent Site';
                logoLink.classList.add('visible');
            }
        }

        // Footer text
        if (parentSiteName && parentSiteUrl) {
            const parentText = document.getElementById('parent-site-text');
            const parentLink = document.getElementById('parent-site-link');
            if (parentText && parentLink) {
                parentLink.href = parentSiteUrl;
                parentLink.textContent = parentSiteName;
                parentText.style.display = 'block';
            }
        }
    }
};

// =============================================================================
// INITIALIZATION
// =============================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Initialize i18n first
    i18n.init();

    // Load site config (async, non-blocking)
    SiteConfig.init();

    window.game = new MorseFleetGame();

    // Initialize speed selector
    const speedSelect = document.getElementById('speed-select');
    speedSelect.addEventListener('change', (e) => {
        const wpm = parseInt(e.target.value, 10);
        MorseTiming.setWPM(wpm);
    });

    // Initialize language selector
    const langSelect = document.getElementById('lang-select');
    langSelect.value = i18n.currentLang;
    langSelect.addEventListener('change', (e) => {
        i18n.setLang(e.target.value);
    });

    // Initialize game mode selector
    const modeSelect = document.getElementById('mode-select');
    modeSelect.addEventListener('change', (e) => {
        const mode = e.target.value;
        window.game.setGameMode(mode);
    });

    // Initialize tutorial
    Tutorial.init();

    // Initialize legal modals
    LegalModals.init();

    // Initialize help modal
    HelpModal.init();

    // Prevent pull-to-refresh on mobile
    document.body.addEventListener('touchmove', (e) => {
        if (e.target.closest('.morse-key-container')) {
            e.preventDefault();
        }
    }, { passive: false });
});
    </script>
</body>
</html>
